\documentclass[envcountsame]{llncs}

\usepackage{isabelle,isabellesym}
\usepackage{graphicx}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{latexsym}
\usepackage{mathrsfs}
\usepackage{stmaryrd}
\usepackage{mathpartir} % inferrules
%\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{color}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[colorinlistoftodos]{todonotes}

\newcommand{\IF}[3]{\mathbf{if}\ #1\ \mathbf{then}\ #2\ \mathbf{else}\ #3}
\newcommand{\WHILE}[2]{\mathbf{while}\ #1\ \mathbf{do}\ #2}
\newcommand{\WHILEI}[3]{\mathbf{while}\ #1\ \mathbf{inv}\ #2\ \mathbf{do}\ #3}
\newcommand{\sskip}{\mathit{skip}}
\newcommand{\MKA}{\mathsf{MKA}}
\newcommand{\KAT}{\mathsf{KAT}}
\newcommand{\rKAT}{\mathsf{rKAT}}
\newcommand{\PDL}{\mathsf{PDL}}
\newcommand{\dL}{\mathsf{d}\mathcal{L}}
\newcommand{\dH}{\mathsf{d}\mathcal{H}}
\newcommand{\dR}{\mathsf{d}\mathcal{R}}
\newcommand{\flow}{\varphi}
\newcommand{\orbit}{\gamma^\varphi}
\newcommand{\lipschitz}{\ell}
\newcommand{\Pow}{\mathcal{P}}
\newcommand{\id}{\mathit{id}}
\newcommand{\Id}{\mathit{Id}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\bools}{\mathbb{B}}
\newcommand{\true}{\top}
\newcommand{\dLprog}{\Pi}
\newcommand{\ad}{\mathit{ad}}
\newcommand{\ar}{\mathit{ar}}
\newcommand{\wlp}{\mathit{wlp}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Rel}{\mathbf{Rel}}
\newcommand{\Sols}{\mathop{\mathsf{Sols}}}
\newcommand{\sta}{\mathsf{Sta}}
\newcommand{\rel}{\mathsf{Rel}}
\newcommand{\inv}{\mathsf{Inv}}

%\newcommand{\guards}[4]{(#1\circ #2)[#3,#4]}
\newcommand{\guards}[3]{#1\mathrel{\triangleright_#3} #2}
\newcommand{\gorbit}[1]{\gamma^#1_G}
\newcommand{\dinvar}[2]{( #1\hbox{ }\mathsf{invariant}\hbox{ }#2)}
%

\definecolor{scolor}{rgb}{1,0.5,0.5}
\definecolor{jcolor}{cmyk}{1,0,1,0}
\definecolor{gcolor}{cmyk}{1,0,0,0}


\newcommand\notein[3]{\todo[inline,linecolor=orange!80!black,backgroundcolor=#2!20]{#1: #3}%yellow!50 
}
\newcommand{\sfin}[1]{\notein{{\bf SF}}{scolor}{#1}}
\newcommand{\jin}[1]{\notein{{\bf JHM}}{jcolor}{#1}}
\newcommand{\gin}[1]{\notein{{\bf GS}}{gcolor}{#1}}

\urlstyle{rm}
\isabellestyle{it}

\begin{document}

\title{Differential Hoare Logics and Refinement Calculi\\ for Hybrid Systems with Isabelle/HOL}
\titlerunning{Hoare Logics and Refinement Calculi for Hybrid
  Systems}

\author{Simon Foster$^1$ \and Jonathan Juli\'an Huerta y Munive$^2$ \and Georg Struth$^2$} \authorrunning{Foster, Huerta y Munive and Struth}

\institute{University of York, UK \and University of Sheffield, UK}

\maketitle

\begin{abstract} 
  We present simple new Hoare logics and refinement calculi for hybrid
  systems in the style of differential dynamic logic. (Refinement)
  Kleene algebra with tests is used for reasoning about the program
  structure and generating verification conditions at this level.
  Lenses capture hybrid program stores in a generic algebraic way. The
  approach has been formalised with the Isabelle/HOL proof
  assistant. A number of examples explains the workflow with the
  resulting verification components.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:introduction}

Differential dynamic logic ($\dL$) is a prominent deductive method for
verifying hybrid systems~\cite{Platzer18}. It extends dynamic logic
with domain-specific inference rules for reasoning about the discrete
control and continuous dynamics that are characteristic for such
systems. Continuous evolutions are modelled in $\dL$'s evolution
commands within a hybrid program syntax. These declare a vector field
and a guard, which is meant to hold along the evolution.  Reasoning
with evolution commands in $\dL$ requires either explicit solutions to
differential equations represented by the vector field, or invariant
sets~\cite{Teschl12} that describe these evolutions implicitly. Verification
components inspired by $\dL$ have already been formalised in the
Isabelle proof assistant~\cite{MuniveS19}. Yet the shallow embedding
used has shifted the focus from the original proof-theoretic approach
to a semantic one, and ultimately to predicate transformer algebras
supporting a quite different workflow.

Dynamic logics and predicate transformers are powerful tools. They
support reasoning about program equivalences and transformations
far beyond what standard program verification requires~\cite{BackW98}. For
the latter, much simpler Hoare logics generate precisely the
verification conditions needed.  Asking about the feasibility of a
\emph{differential Hoare logic} ($\dH$) is therefore natural and
interesting.  As Hoare logic is strongly related to Morgan's
refinement calculus~\cite{Morgan94}, it is equally reasonable to
ask wether and how a Morgan-style \emph{differential refinement calculus}
($\dR$) might allow constructing hybrid programs from specifications.

A prima facie answer to these questions seems positive: after all, the
rules of Hoare logic are derivable within dynamic logic and the laws
of Morgan's refinement calculus can be proved using Hoare logic. But
the formalisms envisaged might not be expressive enough for hybrid
program verification or less suitable than $\dL$ in
practice. Conceptually it is also not obvious what exactly it would
take to extend a standard Hoare logic or refinement calculus to hybrid
programs.

Our main contribution consists in evidence that $\dH$ and $\dR$ are as
feasible and applicable for verifying hybrid programs as $\dL$, and
that developing these novel methods requires simply adding a single
Hoare-style axiom and a single refinement rule for evolution commands
to the standard formalisms.

This conceptual simplicity is reflected by that of the Isabelle
verification components for $\dH$ and $\dR$, which reuse extant
components for (refinement) Kleene algebra with
tests~\cite{Kozen97,ArmstrongGS16,afp:vericomp} $(\mathsf{(r)KAT}$)
for the propositional Hoare logic and refinement calculi---ignoring
assignment and evolution commands---and in which we can derive axioms
and laws for these two basic commands within a concrete state
transformer semantics for hybrid programs~\cite{MuniveS19} over a
generic hybrid store model based on lenses~\cite{FosterZW16}, reusing
mainly other Isabelle components~\cite{afp:hybrid,afp:simon?}.
Data-level verification conditions can be discharged using Isabelle's
impressive hierarchy for analysis and ordinary differential
equations~\cite{ImmlerH12a}.

This simple modular development evidences the benefits of algebraic
reasoning and shallow embeddings with proof assistants. In our
verification components, we merely need to formalise a state
transformer semantics for $\KAT$ and $\rKAT$ along the lines
of~\cite{afp:hybrid} and concrete store semantics for hybrid
programs. Using lenses~\cite{FosterZW16} gives us the flexibility to
switch seamlessly between stores based on real vector spaces or
executable Euclidean spaces. Beyond that it suffices to derive a few
algebraic laws for reasoning with invariants and the Hoare-axioms and
refinement laws for evolution commands in the concrete
semantics. Program verification is then performed at this concrete
level, but this remains hidden, as tactics generate data-level
verification conditions automatically and we have programmed
boiler-plate syntax for programs and correctness specifications.
\jin{I assume below, it's meant ``$\dH$ and $\dR$''}
Our Isabelle components support the  workflows of $\dL$ in $\dH$
and $\dL$: we may reason explicitly with solutions to differential
equations and implicitly with invariant sets. We have formalised a third
method in which solutions, that is flows, are declared ab initio in
correctness specifications and need not be certified.

Our verification components have so far been evaluated on a small set of
program construction and verification examples. Some of them are
discussed in detail in this article to explain the different work
flows supported by our approach. With Isabelle tactics for automated
verification condition generation in place, we notice little
difference relative to our predicate transformer
components~\cite{MuniveS19}.  The entire Isabelle formalisation, is
available online\footnote{Jonathan's repo}; our repository contains
instructions for using it and a postscript proof document that allows
reading the Isabelle code without installing the proof assistant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kleene Algebra with Tests}\label{sec:kat} 

% A \emph{Kleene algebra} is a structure $(K,+,\cdot,0,1,^\ast)$, where
% $(S,+,\cdot,0,1)$ is a semiring with idempotent addition and the
% Kleene star $(-)^\ast:K\to K$ satisfies, for all
% $\alpha,\beta,\gamma\in K$, the axioms
% \begin{align*} 
% 1+\alpha\cdot\alpha^\ast &\le \alpha^\ast, \qquad
%   \gamma+\alpha\cdot
%                                           \beta\le \beta\rightarrow \alpha^\ast \cdot \gamma\le \beta,\\
%   1+\alpha^\ast\cdot\alpha &\le \alpha^\ast, \qquad \gamma+\beta\cdot
%                              \alpha\le \beta\rightarrow \gamma\cdot
%                              \alpha^\ast \le \beta.
% \end{align*}


A \emph{Kleene algebra with tests}~\cite{Kozen97} ($\KAT$) is a
structure $(K,B,+,\cdot,0,1,^\ast,\neg)$ where $(B,+,\cdot,0,1,\neg)$
is a boolean algebra with join $+$, meet $\cdot$, complementation
$\neg$, least element $0$ and greatest element $1$, $B\subseteq K$,
and $(K,+,\cdot,0,1,^\ast)$ is a Kleene algebra---a semiring with
idempotent addition equipped with a star operation that satisfies the
axioms $1+\alpha\cdot\alpha^\ast \le \alpha^\ast$ and
$\gamma+\alpha\cdot \beta\le \beta\rightarrow \alpha^\ast \cdot
\gamma\le \beta$,
as well as their opposities, with multiplication swapped.  The
ordering on $K$ is defined by $x\le y\leftrightarrow x+y=y$, as
idempotent semirings are semilattices. We often write $\alpha\beta$
instead of $\alpha\cdot\beta$, and use $p,q,r,\dots$ for elements of $B$.

Elements of $K$ represent programs; those of $B$ tests, assertions or
propositions.  The operation $\cdot$ models the sequential composition
of programs, $+$ their nondeterministic choice, $(-)^\ast$ their
finite unbounded iteration. Program $0$ aborts and $1$ skips.  Tests
are embedded implicitly into programs. They are meant to hold in some
states of a program and fail in others; $p\alpha$ ($\alpha p$)
restricts the execution of program $\alpha$ in its input (output) to
those states where test $p$ holds. The ordering $\le$ is the opposite
of the refinement ordering on programs (see Section~\ref{sec:refine}).

Binary relations of type $\Pow\, (S\times S)$ form
$\KAT$s~\cite{Kozen97} when $\cdot$ is interpreted as relational
composition, $+$ as relational union, $(-)^\ast$ as
reflexive-transitive closure and the elements of $B$ as
subidentities---relations below the relational unit. This grounds
$\KAT$ within standard relational imperative program semantics. Yet we
prefer the isomorphic representation as \emph{state transformers} of
type $S\to \Pow\, S$.  Composition $\cdot$ is then interpreted as
Kleisli composition
\begin{equation*} 
(f\circ_K g)\, x = \bigcup\{g\, y\mid y \in f\ x \}, 
\end{equation*} 
$0$ as $\lambda x.\ \emptyset$ and $1$ as $\eta_S = \{-\}$.  Stars
$f^{\ast}\, s  = \bigcup_{i\in\mathbb{N}} f^i\, s$ are defined with
  respect to Kleisli composition using $f^{0} = \eta_S$ and
  $f^{n+1} = f \circ_K f^{n}$. The boolean algebra of tests has
  carrier set $B_S=\{f:S\to \Pow\, S \mid f\le \eta_S\}$, where the
  order on functions has been extended pointwise,  and complementation
  is given by
  \begin{equation*} 
    \overline{f}\, x =
  \begin{cases}
    \eta_S\, x, & \text{ if } f\, x = \emptyset,\\
\emptyset, & \text{ otherwise}.
  \end{cases}
\end{equation*}
We freely identify predicates, sets and state 
transformers below $\eta_S$, which are isomorphic:
$P\cong \{s\mid P\, s\}\cong \lambda s.\ \{x\mid x=s \land P\, s\}$.

\begin{proposition}\label{P:kleisli-ka}
$\sta\, S = ((\Pow\, S)^S,B_S,\cup,\circ_K,\lambda x.\
  \emptyset, \eta_S,(-)^{\ast},\overline{(-)})$
  forms a $\KAT$, the \emph{full state transformer $\KAT$} over the
  set $S$.
\end{proposition}
A \emph{state transformer $\KAT$} over $S$ is any subalgebra of
$\sta\, S$. 

We have already formalised $\KAT$ via type classes in
Isabelle~\cite{afp:kat}.  These allow only one type parameter. Hence
we use an alternative approach that expands a Kleene algebra $K$ by an
\emph{antitest} function $n:K\to K$ from which a \emph{test} function
$t:K\to K$ is defined as $t=n^2$. Then
$K_t = \{\alpha \mid t\, \alpha = \alpha\}$ forms a boolean algebra in
which $n$ acts as test complementation. It can be used in place of the
boolean algebra $B$.  A formalisation of the state transformer model
of $\KAT$ is a contribution to this article.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Propositional Hoare Logic and Invariants}\label{sec:hl-invariants}

$\KAT$ provides a simple algebraic semantics for while
programs with
\begin{align*}
  \IF{p}{\alpha}{\beta} = p\cdot \alpha + \bar p \cdot
  \beta\qquad\text{ and }\qquad
\WHILE{p}{\alpha} = (p\cdot \alpha)^\ast \cdot \bar p.
\end{align*}
It captures validity of Hoare triples in
a partial correctness semantics as
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow p\alpha\neg q = 0,
\end{equation*}
or equivalently by $p\alpha\le \alpha q$ or $p\alpha = p\alpha q$. It
also allows deriving the rules of \emph{propositional Hoare
  logic}~\cite{Kozen00}---disregarding assignments---which are useful for
verification condition generation:
\begin{align}
  &\{p\}\, \sskip\, \{p\}, \label{eq:h-skip}\tag{h-skip}\\
  p\le p' \land \{p'\}\, \alpha\, \{q'\} \land q'\le q\ \rightarrow\ &
                                                                       \{p\}\,
                                                                       \alpha\,
                                                                       \{q\},\label{eq:h-cons}\tag{h-cons}\\
  \{p\}\, \alpha\, \{r\} \land \{r\}\, \beta\, \{q\}\ \rightarrow\
  &\{p\}\, \alpha\beta\, \{q\},\label{eq:h-seq}\tag{h-seq}\\
  \{tp\}\, \alpha\, \{q\}\land \{\neg tp\}\, \beta\, \{q\}\
  \rightarrow\ & \{p\}\, \IF{t}{\alpha}{\beta}\, \{q\},\label{eq:h-cond}\tag{h-cond}\\
  \{tp\}\, \alpha\, \{p\}\ \rightarrow\ & \{p\}\, \WHILE{t}{\alpha}\, \{\neg tp\}.\label{eq:h-while}\tag{h-while}
\end{align}
Rules for commands with invariant assertions $\alpha\ \mathbf{inv}\ i$
are derivable, too (operationally,
$\alpha\, \mathbf{inv}\, i = \alpha$).  An \emph{invariant} for
$\alpha\in K$ is an $i\in B$ satisfying $\{i\}\, \alpha\, \{i\}$.
Then, with $\mathbf{loop}\, \alpha$ as syntactic sugar for
$\alpha^\ast$, we obtain
\begin{align}
  p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\
  &\{p\}\, \alpha\, \{q\},\label{eq:h-inv}\tag{h-inv}\\
  p \le i \wedge \{it\}\, \alpha\, \{i\} \wedge \neg t i\le q\
  \rightarrow \ & \{p\}\, \WHILEI{t}{i}{\alpha}\,  \{q\},\label{eq:h-while-inv}\tag{h-while-inv}\\
   p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\ &
                                                                   \{p\}\, \mathbf{loop}\, \alpha\,
    \mathbf{inv}\, i\, \{q\}. \label{eq:h-loop-inv}\tag{h-loop-inv}
\end{align}
We use (\ref{eq:h-inv}) to reason about invariants for continuous
evolutions of hybrid systems in Section~\ref{sec:hoare-inv},
\ref{sec:refine} and \ref{sec:from-flows}. Rule (\ref{eq:h-while-inv})
is standard for reasoning with invariants for while loops;
(\ref{eq:h-loop-inv}) is specific to loops of hybrid programs (see
Section~\ref{sec:sta-hybrid}).

The rules for propositional Hoare logic in Isabelle have been derived
for $\KAT$ in~\cite{afp:kat,afp:vericomp}. Generic Isabelle
infrastructure for reasoning with invariants has been developed
especially for this article.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{State Transformer Semantics for Hybrid
  Programs}\label{sec:sta-hybrid}

\gin{Simon: add some paras on lenses.}

Hybrid programs of differential dynamic logic ($\dL$)~\cite{Platzer18}
are defined by the syntax
\begin{equation*}
\mathcal{C}\ ::= \ x:=e \mid x' = f \, \&\, G \mid ?P\mid \mathcal{C};\mathcal{C}\mid \mathcal{C}+\mathcal{C}\mid \mathcal{C}^*
\end{equation*}
that adds \emph{evolution commands} $x' = f \, \&\, G$ to the language
of $\KAT$---function $?(-)$ embeds tests explicitly into programs.
Evolution commands introduce a time independent vector field $f$ for
an autonomous system of ordinary differential equations
(ODEs)~\cite{Teschl12} together with a guard $G$, a predicate
modelling boundary conditions or similar restrictions on temporal
evolutions. % Guards are also known as \emph{evolution domain
  % restrictions}~\cite{DoyenFPP18}.

Formally, vector fields are functions of type $S\to S$ on some open set
$S\subseteq \reals^n$ and $n\in\mathbb{N}$---the state space of
the hybrid program. We assume that program variables range from $0$ to
$n-1$, or pick them from any set $V$ isomorphic to the finite ordinal
$n$. Program states in $S$ can thus be identified with hybrid program
stores modelled as functions from variables in $V$ to values in
$\reals$, as usual.

Geometrically, vector field $f$ assigns a vector to any point of the
state space
$S$. A solution to the \emph{initial value problem} (IVP) for the pair
$(f,s)$ and initial value $(0,s)\in T\times S$, where $T$ is an open
interval in $\reals$ containing $0$, is then a function $X:T\to S$
that satisfies $X'\, t = f\, (X\, t)$---an autonomous system of ODEs
in vector form---and $X\, 0 = s$. Solution
$X$ is thus a curve in $S$ through $s$, parametrised in $T$ and
tangential to $f$ at any point in $S$; it is called \emph{trajectory}
or \emph{integral curve} of $f$ at $s$ whenever it is uniquely
defined ~\cite{Teschl12}.

For IVP $(f,s)$ with continuous vector field $f:S\to S$ and initial
state $s\in S$ we define the set of solutions on
$T$ as
\begin{equation*}
\Sols f\, T\, s = \left\{X \mid \forall t\in T.\  X'\, t = f\, (X\, t)\land X\, 0 = s\right\}.
\end{equation*}
Each solution $X$ is then continuously differentiable and thus
$f\circ X$ integrable in $T$.  For $X\in \Sols\, f\, T\, s$ and
$G:S\to\bools$, we further define the $G$-\emph{guarded orbit} of $X$
along $T$ in $s$~\cite{MuniveS19} with the help of the state transformer
$\gamma^X_G:S\to \Pow\, S$ as 
\begin{equation*}
\gamma^X_{G}\, s= \left\{X\, t\mid t\in T\land \forall \tau\in
{\downarrow}t.\ G\, (X\, \tau)\right\},
\end{equation*}
where ${\downarrow}t = \left\{t'\in T\mid t'\le t\right\}$, and the
$G$-\emph{guarded orbital} of $f$ along $T$ in $s$~\cite{MuniveS19}
via the state transformer $\gamma^f_G:S\to \Pow\, S$ as
\begin{equation*}
  \gamma^f_G\ s = \bigcup\left\{\gamma^X_G\, s\mid X\in \Sols\, f\, T\, s\right\}.
\end{equation*}
In applications, ${\downarrow}t$ is usually an interval
$[0,t]\subseteq T$.  Expanding definitions,
\begin{equation*}
\gamma^f_G\, s = \left\{X\, t \mid X\in \Sols\, f\, T\, s \land t\in T
\land \forall \tau\in{\downarrow}t.\ G\, (X\, \tau)\right\}.
\end{equation*}
If $\top$ denotes the predicate that holds of all states in $S$ (or
the set $S$ itself), we write $\gamma^f$ instead of
$\gamma^f_\top$. We define the semantics of the evolution command
$x'= f\, \&\, G$~\cite{MuniveS19} for any continuous $f:S\to S$ and
$G:S\to \bools$ as
\begin{equation}
{\left(x'= f\, \&\, G\right)} = \gamma^f_G.\label{eq:st-evl}\tag{st-evl}
\end{equation}

Defining the state transformer semantics of assignments is
standard~\cite{MuniveS19}. First we define a state update
function $f_a:V\to (S \to E) \to S\to S$ as
\begin{equation*}
f_a\, x\, e\, s = s[x\mapsto e\, s],
\end{equation*}
where $f[a\mapsto b]$ updates $f:A\to B$ by associating $a\in A$ with
$b$ and every $y\neq a$ with $f\, y$.  The ``expression''
${e:S\to \reals}$ is thus evaluated in state $s$ to $e\, s$.  Then we
lift $f_a\, x\, e:S\to S$ to state transformer
$x:= e:S \to \Pow\, S$ using $\eta_S$:
\begin{equation}
  (x:= e) = \lambda s.\ \{f_a\, x\, e\, s\}.\label{eq:st-assgn}\tag{st-assgn}
\end{equation}

The development in this section has already been formalised with
Isabelle~\cite{afp:hybrid}, both for a state transformer and a
relational semantics. An instance of the latter for particular vector
fields with unique solutions forms the standard semantics of
$\dL$. Due to the connection to orbits or orbitals, the state
transformer semantics is arguably conceptually simpler and more
elegant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Differential Hoare Logic for Flows}\label{sec:hoare-flow}

\gin{we need to discuss hybrid semantics of hoare triples in detail
  --- how do they work?}

The assignment axiom of Hoare logic need not be explained. Our
semantics yields a variant with update functions instead
of substitutions:
\begin{equation}
\left\{\lambda s.\ P\, s[x\mapsto e\, s]\right\}\,  x:=e\, \{P\}. \label{eq:h-assgn}\tag{h-assgn}
\end{equation}
Hence all we need to add to Hoare logic is a rule for evolution
commands.  We restrict our attention to Lipschitz-continuous vector
fields for which unique solutions to IVPs are guaranteed by
Picard-Lindel\"of's theorem~\cite{Teschl12}.  These are \emph{(local)\
  flows} $\flow:T\to S\to S$ and $X=\flow_s=\lambda t.\ \flow\, t\, s$
is the trajectory at $s$. Guarded orbitals $\gamma^f_G$ then
specialise to \emph{guarded orbits}
\begin{equation*}
  \gamma^f_{G,U} = \left\{\flow_s\, t\mid t\in U\land \forall\tau \in
  {\downarrow}t.\ G\, (\flow_s\, t)\right\},
\end{equation*}
where $U\subseteq T$ is a time domain of interest, typically an
interval $[0,t]$ for some $t\in T$~\cite{MuniveS19}.  Accordingly,
(\ref{eq:st-evl}) becomes
\begin{equation}
  \left(x' = f\, \&\, G\right)= \gamma^f_{G,U}.\label{eq:st-evl-flow}\tag{st-evl-flow}
\end{equation}
The following Hoare-style rule for evolution commands is then
derivable.
\begin{lemma}\label{P:h-evl-lemma}
Let $f:S\to S$ be a Lipschitz continuous vector
field on $S\subseteq \reals^n$, and $\flow:T\to S\to S$, its (local) flow with $0\in T\subseteq \reals$. Then, for $U\subseteq T$ and $G,Q:S\to\bools$
\begin{equation}
\left\{\lambda s\in S.\forall t\in U.\ \left(\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)\right) \rightarrow Q\,
(\flow_s\, t)\right\}\, x' = f\, \&\, G\, \{Q\}. \label{eq:h-evl}\tag{h-evl}
\end{equation}
\end{lemma}

This finishes the derivation of rules for a Hoare logic $\dH$ for
hybrid programs---to our knowledge, the first Hoare logic of this
kind. As usual, there is one rule per programming construct, so that
their recursive application generates proof obligations that are
entirely about data-level relationships---the discrete and continuous
evolution of hybrid program stores.

The rule~(\ref{eq:h-evl}) supports the following procedure
for reasoning with an evolution command $x' = f\, \&\, G$ and set $U$
in this calculus:
\begin{enumerate}
\item Check that vector field $f$ satisfies the conditions for
  Picard-Lindel\"of's theorem ($f$ is Lipschitz continuous and
  $S\subseteq\reals^n$ is open).
\item Supply a (local) flow $\flow$ for $f$ with open interval of
  existence $T$ around $0$.
\item Check that $\flow_s$ solves the IVP $(f,s)$ for each $s\in S$;
  that is, $\flow_s'\, t = f\, (\flow_s\, t)$, $\flow_s\, 0 = s$, and
  $U\subseteq T$.
\item If successful, apply rule~(\ref{eq:h-evl}).
\end{enumerate}

\gin{add example: thermostat (done)}

\begin{example}[Thermostat verification via solutions]\label{ex:therm-sol}
Suppose that a thermostat uses variable $m$ for registering temperature measurements and $b$ for turning its heater on or off. Similarly, $T$ denotes the physical temperature and $t$ is time. At most every $\tau$ minutes, the thermostat sets its chronometer to $0$, registers 
the room temperature, and it turns the heater on (or off) based on this reading. A hybrid program to model this behavior is 
\jin{should we remove $\lambda$'s and write a proper hybrid program?}
\begin{align*}
	\mathsf{Cntrl} = &\ {t:=(\lambda\, s.\ 0)};{m:=(\lambda\, s.\ s_T)};\\
				&\ \IF {(\lambda\, s.\ s_b=0 \land s_m\leq T_{min} + 1)} {b:=(\lambda\, s.\ 1)} {}\\
				&\ \IF {(\lambda\, s.\ s_b=1 \land s_m\geq T_{max} - 1)} {b:=(\lambda\, s.\ 0)} {\mathit{skip}},\\
	\mathsf{Dyn} = &\ \IF {(\lambda\, s.\ s_b=0)} {x' = f_0\, \&\, G_0} {x' = f_L\, \&\, G_L},\\
	\mathsf{Thermostat} = &\ (\mathsf{Cntrl}{;}\mathsf{Dyn})^\ast,
\end{align*}
where we abbreviate $s_v=s\, v$ for $v\in\{T,t,m,b\}$, $L\geq 0$, $a>0$, $U=[0,\tau]$, and the evolution commands involve vector fields and guards,
 \begin{equation*}
    f_c\,
    \begin{pmatrix}
      s_T\\
      s_t\\
	s_m\\
	s_b
    \end{pmatrix}
=
\begin{pmatrix}
  -a\cdot(s_T-c)\\
  1\\
  0\\
  0\\
\end{pmatrix}\quad\text{and}\quad
G_c\, s = \left(s_t\leq -\frac{1}{a}\ln\left(\frac{c-\Delta_c}{c-s_m}\right)\right),
\end{equation*}
where $\Delta_c=T_{min}$ if $c=0$ and $\Delta_c = T_{max}$ if $c=L$. Its correctness specification is $\{I\}\, \mathsf{Thermostat}\, \{I\}$ where $I\, s=T_{min}\leq s_T\leq T_{max}\land (s_b = 1 \lor s_b=0)$.

The temperature 
follows the ODE \isa{T{\isacharprime}\ {\isacharequal}\ {\isacharminus}\ a\ {\isacharasterisk}\ {\isacharparenleft}T\ {\isacharminus}\ U{\isacharparenright}} where \isa{U{\isacharequal}L\ {\isasymge}\ {\isadigit{0}}} when the heater is on, and \isa{U\ {\isacharequal}\ {\isadigit{0}}} when it is off. 



We use \isa{{\isadigit{1}}} to denote the room's temperature, 
\isa{{\isadigit{2}}} is time as measured by the thermostat's chronometer, and \isa{{\isadigit{3}}} is a variable
to save temperature measurements. Finally, \isa{{\isadigit{4}}} states whether the heater is on 
(\isa{s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}}) or off (\isa{s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}}). We prove that the thermostat keeps the room's 
temperature between \isa{Tmin} and \isa{Tmax}.

\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ thermostat{\isacharunderscore}flow{\isacharcolon}\ \isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ a{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ Tmin{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}Tmax\ {\isacharless}\ L{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Hoare\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Tmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Tmax\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isasymrceil}\isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ \ {\isacharparenleft}{\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}{\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymle}\ Tmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ ELSE\ \isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymge}\ Tmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ a\ {\isadigit{0}}{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharminus}\ {\isacharparenleft}ln\ {\isacharparenleft}Tmin{\isacharslash}s{\isachardollar}{\isadigit{3}}{\isacharparenright}{\isacharparenright}{\isacharslash}a{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}\ \isanewline
\ \ \ \ ELSE\ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ a\ L{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharminus}\ {\isacharparenleft}ln\ {\isacharparenleft}{\isacharparenleft}L{\isacharminus}Tmax{\isacharparenright}{\isacharslash}{\isacharparenleft}L{\isacharminus}s{\isachardollar}{\isadigit{3}}{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isacharslash}a{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}\ {\isacharparenright}\isanewline
\ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ Tmin\ {\isasymle}s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Tmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}\isanewline
\ \ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Tmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Tmax{\isasymrceil}{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\end{isabellebody}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Differential Hoare Logic for Invariants}\label{sec:hoare-inv}

Alternatively, $\dH$ supports reasoning with invariants for evolution
commands instead of supplying flows to~(\ref{eq:h-evl}).  The approach
has been developed in~\cite{MuniveS19}. Our invariants generalise the
\emph{differential invariants} of $\dL$~\cite{Platzer18} and the
\emph{invariant sets} of dynamical systems and (semi)group
theory~\cite{Teschl12} .

A predicate $I:S\to\bools$ is an \emph{invariant} of the continuous
vector field $f:S\to S$ and guard $G:S\to\bools$ \emph{along}
$T\subseteq \reals$ if
\begin{equation*}
\bigcup \Pow\, \gamma^f_G\, I\subseteq  I.
\end{equation*}
The operation $\bigcup\circ\Pow$ is the Kleisli extension $(-)^\dagger$
in the powerset monad. Hence we could simply write
$(\gamma^f_gG)^\dagger\, I \subseteq I$. The definition of invariance
unfolds to
\begin{equation*}
  \forall s.\ I\, s \to (\forall X\in\Sols f\, T\, s.\forall t\in T.\ (\forall \tau\in {\downarrow}t.\ G\, (X\, \tau)) \to I\, (X\, t)).
\end{equation*}
For $G=\top$ we call $I$ an \emph{invariant} of $f$ along $T$.
Intuitively, invariants can be seen as sets of orbits.

Invariants for evolution commands are coherent with those in Section~\ref{sec:hl-invariants}.
\begin{proposition}\label{P:inv-prop}
  Let $f:S\to S$ be continuous, $G:S\to\bools$ and
  $T\subseteq \reals$. Then $I$ is an invariant for $f$ and $G$ \emph{along} $T$ if and only if
$ \{I\}\, x' = f\, \&\, G\, \{I\}$.
\end{proposition}
Hence we can use an instance of (\ref{eq:h-inv}) for verification condition generation:
\begin{align}
  P\le I \land \{I\}\, x' = f\, \&\, G\, \{I\}\land (I\cdot G)\le Q\ \rightarrow\
  &\{P\}\, x' = f\, \&\, G\, \{Q\}.\label{eq:h-invg}\tag{h-invg}
\end{align}
It remains to check invariance in the antecedent of this rule. The
following lemma leads to a procedure.

\begin{lemma}\label{P:invrules}
  Let $f:S\to S$ be a continuous vector field, $\mu,\nu:S\to\reals$
  differentiable and $T\subseteq \reals$. 
\begin{enumerate}
\item If $(\mu\circ X)' =(\nu\circ X)'$ for all
  $X\in \Sols f\, T\, s$, then $\{\mu=\nu\}\, x' = f\, \&\, G\, \{\mu=\nu\}$, 
\item if $(\mu\circ X)'\, t\leq(\nu\circ X)'\, t$ when $t> 0$, and $(\mu\circ X)'\, t\geq(\nu\circ X)'\, t$ when $t< 0$, for all $X\in \Sols f\, T\, s$,
  then $\{\mu <\nu\}\, x' = f\, \&\, G\, \{\mu <\nu\}$
\item $\mu\neq \nu$ if and only if $\mu < \nu$ or $\nu < \mu$,
\item $\mu \not\le \nu$ if and only if $\nu < \mu$,
\jin{get Hoare triple version in Isabelle}
\item if $\{I_i\}\, x' = f\, \&\, G\, \{I_i\}$for $i\in\{1,2\}$, then $\{I_1\land I_2\}\, x' = f\, \&\, G\, \{I_1\land I_2\}$ and $\{I_1\lor I_2\}\, x' = f\, \&\, G\, \{I_1\lor I_2\}$.
%\item if $I_1$ and $I_2$ are differential invariants for $f$ along $T$, then so are $\lambda s.\ I_1\, s \land I_2\, s$ and $\lambda s.\ I_1\, s \lor I_2\, s$.
\end{enumerate}
\end{lemma}

Condition $(1)$ follows from the well known fact that two continuously
differentiable functions are equal if they intersect at some point and their
derivatives are equal. Therefore, rule (\ref{eq:h-invg}),
Proposition~\ref{P:inv-prop} and Lemma~\ref{P:invrules} yield the following
procedure for verifying a triple $\{P\}\, x' = f\, \&\, G\, \{Q\}$
using an invariant.
\begin{enumerate}
\item Check whether a candidate predicate $I$ is an invariant for $f$
  along $T$:
	\begin{enumerate}
	\item transform $I$ into negation normal form;
	\item if $I$ is complex, reduce it with Lemma~\ref{P:invrules} (3), (4) and (5);
	\item if $I$ is atomic, apply Lemma~\ref{P:invrules} (1) and (2);
	\end{enumerate}
(if successful,  $\{I\}\, x' = f\, \&\, G\, \{I\}$ holds by Proposition~\ref{P:inv-prop}),
\item if successful, prove $P\le I$ and $(I\cdot G)\le Q$ to apply rule (\ref{eq:h-invg}).
\end{enumerate}

\gin{add example: water tank (done)}

\begin{example}[Water tank verification via invariants]\label{ex:tank-inv}
\begin{isabellebody}
\isacommand{lemma}\isamarkupfalse%
\ water{\isacharunderscore}tank{\isacharunderscore}inv{\isacharcolon}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ c\isactrlsub o{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}c\isactrlsub o\ {\isacharless}\ c\isactrlsub i{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Hoare\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Hmin\ {\isacharless}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isacharless}\ Hmax\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isasymrceil}\isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ \ {\isacharparenleft}{\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}{\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymle}\ Hmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ ELSE\ \isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymge}\ Hmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ c\isactrlsub i\ c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharparenleft}Hmax\ {\isacharminus}\ s{\isachardollar}{\isadigit{4}}{\isacharparenright}{\isacharslash}{\isacharparenleft}c\isactrlsub i\ {\isacharminus}\ c\isactrlsub o{\isacharparenright}{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline
\ \ \ \ \ \ \ DINV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isacharparenleft}{\isacharparenleft}c\isactrlsub i\ {\isacharminus}\ c\isactrlsub o{\isacharparenright}{\isacharparenright}\ {\isacharasterisk}\ s{\isachardollar}{\isadigit{2}}\ {\isacharplus}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isasymge}\ {\isadigit{0}}\ {\isasymand}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymle}\ Hmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{3}}\ {\isacharequal}{\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ \ ELSE\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ {\isadigit{0}}\ c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharparenleft}s{\isachardollar}{\isadigit{4}}\ {\isacharminus}\ Hmin{\isacharparenright}{\isacharslash}c\isactrlsub o{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline
\ \ \ \ \ \ \ DINV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isacharparenleft}{\isacharminus}\ c\isactrlsub o{\isacharparenright}\ {\isacharasterisk}\ s{\isachardollar}{\isadigit{2}}\ {\isacharplus}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isasymge}\ {\isadigit{0}}\ {\isasymand}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymle}\ Hmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{3}}\ {\isacharequal}{\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isacharparenright}\ {\isacharparenright}\isanewline
\ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Hmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{3}}\ {\isacharequal}{\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}\isanewline
\ \ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Hmax{\isasymrceil}{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\end{isabellebody}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Differential Refinement Calculi}\label{sec:refine}

A \emph{refinement Kleene algebra with tests}
($\rKAT$)~\cite{ArmstrongGS16}  is a $\KAT$
$(K,B)$ expanded by an operation $[-,-]:B\times B\to K$ that
satisfies, for all $\alpha \in K$ and $p,q\in B$, 
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow \alpha\le [p,q].
\end{equation*}
The element $[p,q]$ of $K$ corresponds to Morgan's \emph{specification
  statement}~\cite{Morgan94}. It satisfies
\begin{equation*}
  \{p\}\, [p,q]\, \{q\}\qquad \text{ and }\qquad \{p\}\, \alpha\, \{q\} \rightarrow \alpha\le [p,q],
\end{equation*}
which makes $[p,q]$ the greatest element of $K$ that satisfies the Hoare
triple with precondition $p$ and postcondition $q$.  Indeed, in
$\sta\, S$ and for $S\subseteq \reals^n$,
\begin{equation*}
  [P,Q] = \bigcup \left\{f:S\to \Pow\, S \mid \{P\}\, f\, \{Q\}\right\}.
\end{equation*}

Variants of Morgan's laws~\cite{Morgan94} of a \emph{propositional
  refinement calculus}---once more ignoring assignments---are then derivable in
$\rKAT$~\cite{ArmstrongGS16}.
\begin{align}
  1 &\le [p,p],\label{eq:r-skip}\tag{r-skip}\\
[p',q'] &\le [p,q],\qquad \text{ if } p\le p'\text{ and } q'\le q,\label{eq:r-cons}\tag{r-cons}\\
\alpha & \le [0,1],\\
[1,0] &\le \alpha,\\
[p,r]\cdot [r,q] &\le [p,q],\label{eq:r-seq}\tag{r-seq}\\
\IF{t}{[tp,q]}{[\neg tp,q]} &\le [p,q],\label{eq:r-cond}\tag{r-cond}\\
 \WHILE{t}{[tp,p]} &\le [p,\neg tp]. \label{eq:r-while}\tag{r-while}
\end{align}
For invariants and loops, we obtain the additional refinement laws
\begin{align}
  [i,i] &\le [p,q],\qquad \text{ if } p\le i \le q,\label{eq:r-inv}\tag{r-inv}\\
\mathbf{loop} [i,i] &\le [i,i]. \label{eq:r-loop}\tag{r-loop}
\end{align}

In $\sta\, S$, moreover, the following assignments laws are
derivable~\cite{ArmstrongGS16}.
\begin{align}
 (x := e)  &\le  \left[\lambda s.\ Q\, s[x\mapsto e\, s],Q\right],\label{eq:r-assgn}\tag{r-assgn}\\
(x:= e) \cdot \left[Q,Q\right] &\le [\lambda s.\ Q\, s[x\mapsto e\, s],Q],\label{eq:r-assgn}\tag{r-assgnl}\\
\left[Q,\lambda s.\ Q\, s[x\mapsto e\, s]\right]\cdot (x:=e) &\le [Q,Q]. \label{eq:r-assgn}\tag{r-assgnf}
\end{align}
The second and third law are known as \emph{leading} and \emph{following}
law. They introduce an assignment before and after a block of code. 

Finally, we obtain the following refinement laws for evolution
commands.
\begin{lemma}\label{P:r-evl-lemma}
Let $f:S\to S$ be a Lipschitz continuous vector
field on $S\subseteq \reals^n$, and $\flow:T\to S\to S$, its (local) flow with $0\in T\subseteq \reals$. Then, for $U\subseteq T$ and $G,Q:S\to\bools$
\begin{gather*}
x' = f\, \&\, G \le [\lambda s.\forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evl}\tag{r-evl}\\
(x' = f\, \&\, G) \cdot \left[Q,Q\right] \le [\lambda s. \forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evll}\tag{r-evll}\\
\left[Q,\lambda s. \forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t)\right]\cdot (x' = f\, \&\, G) \le [Q,Q].\label{eq:r-evlr}\tag{r-evlr}\\
\end{gather*}
\end{lemma}

Taken together, the laws in this section form the differential
refinement calculus $\dR$.  They suffice for constructing hybrid
programs from initial specification statements by step-wise refinement
incrementally and compositionally. To our knowledge $\dR$ is the first
refinement calculus for hybrid programs of this kind.  A more powerful
variant based on predicate transformers \`a la Back and von
Wright~\cite{BackW98} has been developed in~\cite{MuniveS19}, but
applications remain to be explored.  A previous approach to refinement
for hybrid programs in $\dL$~\cite{LoosP16} is quite different to the
two standard calculi mentioned and much more intricate than the
approach presented.

\gin{do two examples; one for flows (thermostat, stepwise, done), one for
  invariants (water tank, in one go,  with ex euclidean space, tbd).}

\begin{example}[Thermostat refinement via solutions]\label{ex:therm-rsol}
\begin{isabellebody}
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}thermostat{\isacharunderscore}flow{\isacharcolon}\ \isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}a\ {\isachargreater}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ Tmin{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}Tmax\ {\isacharless}\ L{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Tmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Tmax\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isasymrceil}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Tmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Tmax{\isasymrceil}\ {\isasymge}\ \isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ \ {\isacharparenleft}{\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}{\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymle}\ Tmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ ELSE\ \isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymge}\ Tmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ a\ {\isadigit{0}}{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharminus}\ {\isacharparenleft}ln\ {\isacharparenleft}Tmin{\isacharslash}s{\isachardollar}{\isadigit{3}}{\isacharparenright}{\isacharparenright}{\isacharslash}a{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}\ \isanewline
\ \ \ \ ELSE\ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ a\ L{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharminus}\ {\isacharparenleft}ln\ {\isacharparenleft}{\isacharparenleft}L{\isacharminus}Tmax{\isacharparenright}{\isacharslash}{\isacharparenleft}L{\isacharminus}s{\isachardollar}{\isadigit{3}}{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isacharslash}a{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}\ {\isacharparenright}\isanewline
\ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ Tmin\ {\isasymle}s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Tmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\end{isabellebody}
\end{example}

\begin{example}[Water tank refinement via invariants]\label{ex:tank-rinv}
\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}water{\isacharunderscore}tank{\isacharunderscore}inv{\isacharcolon}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ c\isactrlsub o{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}c\isactrlsub o\ {\isacharless}\ c\isactrlsub i{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Hmin\ {\isacharless}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isacharless}\ Hmax\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isasymrceil}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Hmax{\isasymrceil}\ {\isasymge}\isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ \ {\isacharparenleft}{\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}{\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymle}\ Hmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ ELSE\ \isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymge}\ Hmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ c\isactrlsub i\ c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharparenleft}Hmax\ {\isacharminus}\ s{\isachardollar}{\isadigit{4}}{\isacharparenright}{\isacharslash}{\isacharparenleft}c\isactrlsub i\ {\isacharminus}\ c\isactrlsub o{\isacharparenright}{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline
\ \ \ \ \ \ \ DINV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isacharparenleft}{\isacharparenleft}c\isactrlsub i\ {\isacharminus}\ c\isactrlsub o{\isacharparenright}{\isacharparenright}\ {\isacharasterisk}\ s{\isachardollar}{\isadigit{2}}\ {\isacharplus}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isasymge}\ {\isadigit{0}}\ {\isasymand}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymle}\ Hmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{3}}\ {\isacharequal}{\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ \ ELSE\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}x{\isasymacute}{\isacharequal}{\isacharparenleft}f\ {\isadigit{0}}\ c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{2}}\ {\isasymle}\ {\isacharparenleft}s{\isachardollar}{\isadigit{4}}\ {\isacharminus}\ Hmin{\isacharparenright}{\isacharslash}c\isactrlsub o{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline
\ \ \ \ \ \ \ DINV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isacharparenleft}{\isacharminus}\ c\isactrlsub o{\isacharparenright}\ {\isacharasterisk}\ s{\isachardollar}{\isadigit{2}}\ {\isacharplus}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isasymge}\ {\isadigit{0}}\ {\isasymand}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{4}}\ {\isasymand}\ s{\isachardollar}{\isadigit{4}}\ {\isasymle}\ Hmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{3}}\ {\isacharequal}{\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isacharparenright}\ {\isacharparenright}\isanewline
\ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ Hmin\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ Hmax\ {\isasymand}\ {\isacharparenleft}s{\isachardollar}{\isadigit{3}}\ {\isacharequal}{\isadigit{0}}\ {\isasymor}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ {\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\ {\isacharparenleft}\isakeyword{is}\ {\isachardoublequoteopen}LOOP\ {\isacharparenleft}{\isacharquery}ctrl{\isacharsemicolon}{\isacharquery}dyn{\isacharparenright}\ INV\ {\isacharquery}I\ {\isasymle}\ {\isacharquery}ref{\isachardoublequoteclose}{\isacharparenright}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\end{isabellebody}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Evolution Commands for Flows}\label{sec:from-flows}

Finally, we present variants of $\dH$ and $\dR$ that start directly
from flows $\flow:T\to S\to S$ instead of vector fields.  This avoids
checking the conditions of the Picard-Lindel\"of theorem and
simplifies verification proofs considerably.  Instead of
$x'=f\, \&\, G$, we now use the basic evolution command
$\mathbf{evol}\, \flow\, G$ in hybrid programs and define
\begin{equation*}
  (\mathbf{evol}\, \flow\, G) = \lambda s.\ \gamma^{\flow_s}_G\, s
\end{equation*}
with respect to the guarded orbit of $\flow_s$ along $T$ in $s$. It
then remains to derive a Hoare-style axiom and a refinement law
for such evolution commands. This is straightforward.
\begin{lemma}\label{P:hr-evlfl}
Let $\flow:T\to S\to S$ where $T$ is a preorder, then for $G,P,Q:S\to \bools$
\begin{gather*}
\{\lambda s\in S.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)) \rightarrow P\,
(\flow_s\, t)\}\, \mathbf{evol}\, \flow\, G\, \{P\}. \label{eq:h-evlfl}\tag{h-evlfl}\\
\mathbf{evol}\, \flow\, G \le [\lambda s.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evlf}\tag{r-evlf}\\
(\mathbf{evol}\, \flow\, G) \cdot \left[Q,Q\right] \le [\lambda s. \forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evlfl}\tag{r-evlfl}\\
\left[Q,\lambda s. \forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t)\right]\cdot (\mathbf{evol}\, \flow\, G) \le [Q,Q].\label{eq:r-evlfr}\tag{r-evlfr}\\
\end{gather*}
\end{lemma}

\gin{do following and leading assignments laws and bouncing ball
  examples for verification (done) and refinement (step wise, with ex euclidean
  space, tbd).}

\begin{example}[Bouncing ball via Hoare logic]\label{ex:ball-hoare}
  Suppose a ball of mass $m$ falls down from height $h\geq 0$, with
  $x$ denoting its position, $v$ its velocity and $g$ its
  acceleration. Its kinematics is modelled by the vector field
  $f:\reals^V\to\reals^V$ with
 \begin{equation*}
    f\,
    \begin{pmatrix}
      s_x\\
      s_v
    \end{pmatrix}
=
\begin{pmatrix}
  s_v\\
-g
\end{pmatrix},
\end{equation*}
where we abbreviate
$s_x = s\, x$ and $s_v = s\, v$.  It bounces back
from the ground in an elastic collision, which is modelled using a
discrete control that checks whether $s_x=0$ and then flips the
velocity.  Guard $G=(\lambda s.\ s_x\geq 0)$ excludes any motion
below the ground. This is modelled by the hybrid
program~\cite{Platzer18}
\begin{align*}
	\mathsf{Cntrl} &= \IF {(\lambda\, s.\ s_x=0)} {v:=(\lambda\, s.\ - s_v)} \mathit{skip},\\
	\mathsf{Ball} &= ({x'=f\, \&\, G}\,  {;}\, \mathsf{Cntrl})^\ast.
\end{align*}
Its correctness specification is
\begin{equation*}
\{P\}\, \mathsf{Ball}\, \{Q\}
\end{equation*}
for $P= (\lambda s.\ s_x = h\land s_v = 0)$ and $Q  = (\lambda s.\
0\leq s_x\leq h)$; its loop invariant
\begin{equation*}
      I = \left(\lambda s.\ 0\le s_x \land \frac{1}{2}s_v^2= g(h - s_x)\right).
\end{equation*}

\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ bouncing{\isacharunderscore}ball{\isacharunderscore}dyn{\isacharcolon}\ {\isachardoublequoteopen}g\ {\isacharless}\ {\isadigit{0}}\ {\isasymLongrightarrow}\ h\ {\isasymge}\ {\isadigit{0}}\ {\isasymLongrightarrow}\ Hoare\isanewline
\ \ {\isasymlceil}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ h\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}{\isasymrceil}\isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}{\isacharparenleft}EVOL\ {\isacharparenleft}{\isasymphi}\ g{\isacharparenright}\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isasymge}\ {\isadigit{0}}{\isacharparenright}\ T{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isacharminus}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ h\ {\isacharplus}\ s{\isachardollar}{\isadigit{2}}\ {\isasymcdot}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}\isanewline
\ \ {\isacharparenright}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ h{\isasymrceil}{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\end{isabellebody}

\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}bouncing{\isacharunderscore}ball{\isacharunderscore}dyn{\isacharcolon}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}g\ {\isacharless}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}h\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ h\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}{\isasymrceil}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ h{\isasymrceil}\ {\isasymge}\ \isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}{\isacharparenleft}EVOL\ {\isacharparenleft}{\isasymphi}\ g{\isacharparenright}\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isasymge}\ {\isadigit{0}}{\isacharparenright}\ T{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isacharminus}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ h\ {\isacharplus}\ s{\isachardollar}{\isadigit{2}}\ {\isasymcdot}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\end{isabellebody}

\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}\label{sec:conclusion}

We have contributed new methods and Isabelle components to an open
modular semantic framework for verifying hybrid systems that so far
focussed on predicate transformer methods~\cite{MuniveS19}; more
specifically
\begin{itemize}
\item the first standalone Hoare logic $\dH$ for hybrid programs, 
\item the first Morgan-style refinement calculus $\dR$ for such programs,
\item more generic state spaces modelled by lenses,
\item improved Isabelle syntax for correctness specifications
  and hybrid programs,
\item increased proof automation via Isabelle tactics. 
\end{itemize}
As previously~\cite{MuniveS19}, these components support three
workflows based on certifying solutions to Lipschitz-continuous vector
fields, reasoning with invariant sets for continuous vector fields,
and working directly with flows without certification. 

Compared to the standard $\dL$ toolchain, $\dH$ and $\dR$ are
simple. They emphasise the natural mathematical style of reasoning
about dynamical systems, with minimal conceptual overhead relative to
standard Hoare logics and refinement calculi, instead of using
intricate idiosyncratic proof systems. The inference system of $\dH$,
in particular, remains invisible and is only used for automated
verification condition generation. The modular approach with algebras
and a shallow embedding has simplified the construction of these
verification components and made it incremental relative to extant
ones. Our framework is not only open to use any proof method and
mathematical approach supported by Isabelle, it should also allow
developers to add new methods, for instance based on discrete
dynamical systems, hybrid automata or duration calculi~\cite{***} with
minimal effort. It should be equally straightforward to formalise
$\dH$ and $\dR$ based on other Hoare logics supported by Isabelle by
plugging in our hybrid store models.

The relevance of Hoare logic and refinement calculi for hybrid systems
verification is further evidenced by the fact that such approaches are
not new: A hybrid Hoare logic has been proposed by Liu et
al.~\cite{LiuLQZZZZ10} for a duration calculus based on hybrid CSP and
been widely used since. Yet it is conceptually very different from
$\dH$ and $\dL$. A differential refinement logic based on $\dL$ has
been developed as part of Loos' PhD work~\cite{LoosP16}.  It is based
on a complex proof system with a large number of inference rules for
reasoning about inequalities between $\KAT$ expressions, which are
interpreted in a rather non-standard way as refinements between hybrid
programs. It differs substantially from the algebraic calculi
developed by Back and von Wright~\cite{BackW98},
Morgan~\cite{Morgan94} and others, and thus from the predicate
transformer algebras in~\cite{MuniveS19} and from $\dR$.  The relative
advantages and disadvantages of these approaches remain to be
explored.

The expressivity and complexity gap between Hoare logic and predicate
transformer semantics is particularly apparent within algebra. The
weakest liberal precondition operator---a standard predicate
transformer---cannot be expressed in $\KAT$~\cite{Struth18}.  The
equational theory of $\KAT$, which captures propositional Hoare logic,
is PSPACE complete, that of modal Kleene algebra, which yields
predicate transformers, is in EXPTIME~\cite{MollerS06}.  

Finally, while $\KAT$ and $\rKAT$ are convenient starting points for
building program construction and verification components for hybrid
programs, the simple and more general setting of Hoare
semigroups~\cite{Struth18} would support developing hybrid Hoare
logics for total program correctness---where balls may bounce
forever---or even for multirelational
semantics~\cite{FurusawaS16,FurusawaS15} as needed for differential
game logic~\cite{Platzer15}. This, however, is left for future work.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\bibliographystyle{abbrv}
\bibliography{hybrid-kat.bib}

\end{document}