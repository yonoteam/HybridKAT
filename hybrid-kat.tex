\documentclass[envcountsame,envcountsect]{llncs}

\usepackage{isabelle,isabellesym}
\usepackage{graphicx}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{latexsym}
\usepackage{mathrsfs}
\usepackage{stmaryrd}
\usepackage{mathpartir} % inferrules
%\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{color}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[colorinlistoftodos]{todonotes}


\newcommand{\IF}[3]{\mathbf{if}\ #1\ \mathbf{then}\ #2\ \mathbf{else}\ #3}
\newcommand{\WHILE}[2]{\mathbf{while}\ #1\ \mathbf{do}\ #2}
\newcommand{\WHILEI}[3]{\mathbf{while}\ #1\ \mathbf{inv}\ #2\ \mathbf{do}\ #3}
\newcommand{\sskip}{\mathit{skip}}
\newcommand{\MKA}{\mathsf{MKA}}
\newcommand{\KAT}{\mathsf{KAT}}
\newcommand{\rKAT}{\mathsf{rKAT}}
\newcommand{\PDL}{\mathsf{PDL}}
\newcommand{\dL}{\mathsf{d}\mathcal{L}}
\newcommand{\dH}{\mathsf{d}\mathcal{H}}
\newcommand{\dR}{\mathsf{d}\mathcal{R}}
\newcommand{\flow}{\varphi}
\newcommand{\orbit}{\gamma^\varphi}
\newcommand{\lipschitz}{\ell}
\newcommand{\Pow}{\mathcal{P}}
\newcommand{\id}{\mathit{id}}
\newcommand{\Id}{\mathit{Id}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\bools}{\mathbb{B}}
\newcommand{\true}{\top}
\newcommand{\dLprog}{\Pi}
\newcommand{\ad}{\mathit{ad}}
\newcommand{\ar}{\mathit{ar}}
\newcommand{\wlp}{\mathit{wlp}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Rel}{\mathbf{Rel}}
\newcommand{\Sols}{\mathop{\mathsf{Sols}}}
\newcommand{\sta}{\mathsf{Sta}}
\newcommand{\rel}{\mathsf{Rel}}
\newcommand{\inv}{\mathsf{Inv}}

%\newcommand{\guards}[4]{(#1\circ #2)[#3,#4]}
\newcommand{\guards}[3]{#1\mathrel{\triangleright_#3} #2}
\newcommand{\gorbit}[1]{\gamma^#1_G}
\newcommand{\dinvar}[2]{( #1\hbox{ }\mathsf{invariant}\hbox{ }#2)}
%

\newcommand{\defs}{\triangleq}

\definecolor{scolor}{rgb}{1,0.5,0.5}
\definecolor{jcolor}{cmyk}{1,0,1,0}
\definecolor{gcolor}{cmyk}{1,0,0,0}


\newcommand\notein[3]{\todo[inline,linecolor=orange!80!black,backgroundcolor=#2!20]{#1: #3}%yellow!50 
}
\newcommand{\sfin}[1]{\notein{{\bf SF}}{scolor}{#1}}
\newcommand{\jin}[1]{\notein{{\bf JHM}}{jcolor}{#1}}
\newcommand{\gin}[1]{\notein{{\bf GS}}{gcolor}{#1}}

% Lenses

\newcommand{\lput}{\textit{\textsf{put}}}
\newcommand{\lget}{\textit{\textsf{get}}}
\newcommand{\lquad}[4]{\left\langle #1 ~\middle|~ #2 ~\middle|~ #3 ~\middle|~ #4 \right\rangle}
\newcommand{\lcreate}{\textit{\textsf{create}}}
\newcommand{\lto}{\Longrightarrow}
\newcommand{\ltto}{\Longmapsto}
\newcommand{\lbto}{\Longleftrightarrow}
\newcommand{\lsubseteq}{\preceq}
\newcommand{\lsupseteq}{\mathop{\supseteq_\lsbs}}
\newcommand{\lequiv}{\approx}
\newcommand{\lcomp}{\fatsemi}
\newcommand{\lplus}{+}
\newcommand{\lindep}{\mathop{\,\bowtie\,}}
\newcommand{\lone}{\mathbf{1}}
\newcommand{\lzero}{\mathbf{0}}
\newcommand{\lfst}{\textit{\textsf{\textbf{fst}}}}
\newcommand{\lsnd}{\textit{\textsf{\textbf{snd}}}}
\newcommand{\unrest}{\mathop{\sharp}}
\newcommand{\seq}{\mathop{\,;\,}}

\urlstyle{rm}
\isabellestyle{it}

\begin{document}

\title{Differential Hoare Logics and Refinement Calculi\\ for Hybrid Systems with Isabelle/HOL}

\titlerunning{Hoare Logics and Refinement Calculi for Hybrid
  Systems}

\author{Simon Foster$^1$ \and Jonathan Juli\'an Huerta y Munive$^2$ \and Georg Struth$^2$} \authorrunning{Foster, Huerta y Munive and Struth}

\institute{University of York, UK \and University of Sheffield, UK}

\maketitle

\begin{abstract} 
  We present simple new Hoare logics and refinement calculi for hybrid
  systems in the style of differential dynamic logic. (Refinement)
  Kleene algebra with tests is used for reasoning about the program
  structure and generating verification conditions at this level.
  Lenses capture hybrid program stores in a generic algebraic way. The
  approach has been formalised with the Isabelle/HOL proof
  assistant. A number of examples explains the workflow with the
  resulting verification components.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:introduction}

Differential dynamic logic ($\dL$) is a prominent deductive method for
verifying hybrid systems~\cite{Platzer18}. It extends dynamic logic
with domain-specific inference rules for reasoning about the discrete
control and continuous dynamics that characterise such
systems. Continuous evolutions are modelled by $\dL$'s evolution
commands within a hybrid program syntax. These declare a vector field
and a guard, which is meant to hold along the evolution.  Reasoning
with evolution commands in $\dL$ requires either explicit solutions to
differential equations represented by the vector field, or invariant
sets~\cite{Teschl12} that describe these evolutions implicitly. Verification
components inspired by $\dL$ have already been formalised in the
Isabelle proof assistant~\cite{MuniveS19}. Yet the shallow embedding
used has shifted the focus from the original proof-theoretic approach
to a semantic one, and ultimately to predicate transformer algebras
supporting a quite different workflow.

Dynamic logics and predicate transformers are powerful tools. They
support reasoning about program equivalences and transformations
far beyond what standard program verification requires~\cite{BackW98}. For
the latter, much simpler Hoare logics generate precisely the
verification conditions needed.  Asking about the feasibility of a
\emph{differential Hoare logic} ($\dH$) is therefore natural and
interesting.  As Hoare logic is strongly related to Morgan's
refinement calculus~\cite{Morgan94}, it is equally reasonable to
ask wether and how a Morgan-style \emph{differential refinement calculus}
($\dR$) might allow constructing hybrid programs from specifications.

A prima facie answer to these questions seems positive: after all, the
laws of Morgan's refinement calculus can be proved using the rules of
Hoare logic, which in turn are derivable within dynamic logic. But the
formalisms envisaged might not be expressive enough for hybrid program
verification or less suitable than $\dL$ in practice. Conceptually it
is also not obvious what exactly it would take to extend a standard
Hoare logic or refinement calculus to hybrid programs.

Our main contribution consists in evidence that $\dH$ and $\dR$ are as
feasible and applicable for verifying hybrid programs as $\dL$, and
that developing these novel methods requires simply adding a single
Hoare-style axiom and a single refinement rule for evolution commands
to the standard formalisms.

This conceptual simplicity is reflected in the Isabelle verification
components for $\dH$ and $\dR$. These reuse components for
(refinement) Kleene algebra with
tests~\cite{Kozen97,ArmstrongGS16,afp:vericomp} $(\mathsf{(r)KAT}$)
for the propositional Hoare logic and refinement calculi---ignoring
assignment and evolution commands. The axioms and laws for these two
basic commands are derived in a concrete state transformer semantics
for hybrid programs~\cite{MuniveS19} over a generic hybrid store model
based on lenses~\cite{FosterZW16}, reusing other Isabelle
components~\cite{afp:hybrid,Foster18c-Optics,Foster19a-IsabelleUTP}.
Data-level verification conditions are discharged using Isabelle's
impressive components for ordinary differential
equations~\cite{ImmlerH12a}.

This simple modular development evidences the benefits of algebraic
reasoning and shallow embeddings with proof assistants. Our
verification components merely require formalising a state transformer
semantics for $\KAT$ and $\rKAT$ along the lines of~\cite{afp:hybrid}
and concrete store semantics for hybrid
programs. Lenses~\cite{FosterZW16} gives us the flexibility to switch
seamlessly between stores based on real vector spaces or executable
Euclidean spaces. Beyond that it suffices to derive a few algebraic
laws for invariants and the Hoare-axioms and refinement laws for
evolution commands in the concrete semantics. Program verification is
then performed at this concrete level, but this remains hidden, as
tactics generate data-level verification conditions automatically and
we have programmed boiler-plate syntax for programs and correctness
specifications.

Our Isabelle components support the  workflows of $\dL$ in $\dH$
and $\dR$. We may reason explicitly with solutions to differential
equations and implicitly with invariant sets. We have formalised a third
method in which solutions, that is flows, are declared ab initio in
correctness specifications and need not be certified.

Our verification components have been evaluated on a small set
of program construction and verification examples. We discuss some of
them in detail to explain the different work flows supported by our
approach. With Isabelle tactics for automated verification condition
generation in place, we notice little difference relative to our
predicate transformer components~\cite{MuniveS19}.  The entire
Isabelle formalisation, is available online\footnote{Jonathan's repo};
our repository contains instructions for using it and a postscript
proof document that allows reading the Isabelle code without
installing the proof assistant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kleene Algebra with Tests}\label{sec:kat} 

A \emph{Kleene algebra with tests}~\cite{Kozen97} ($\KAT$) is a
structure $(K,B,+,\cdot,0,1,^\ast,\neg)$ where $(B,+,\cdot,0,1,\neg)$
is a boolean algebra with join $+$, meet $\cdot$, complementation
$\neg$, least element $0$ and greatest element $1$, $B\subseteq K$,
and $(K,+,\cdot,0,1,^\ast)$ is a Kleene algebra---a semiring with
idempotent addition equipped with a star operation that satisfies the
axioms $1+\alpha\cdot\alpha^\ast \le \alpha^\ast$ and
$\gamma+\alpha\cdot \beta\le \beta\rightarrow \alpha^\ast \cdot
\gamma\le \beta$,
as well as their opposities, with multiplication swapped.  The
ordering on $K$ is defined by $x\le y\leftrightarrow x+y=y$, as
idempotent semirings are semilattices. We often write $\alpha\beta$
instead of $\alpha\cdot\beta$, and use $p,q,r,\dots$ for elements of $B$.

Elements of $K$ represent programs; those of $B$ tests, assertions or
propositions.  The operation $\cdot$ models the sequential composition
of programs, $+$ their nondeterministic choice, $(-)^\ast$ their
finite unbounded iteration. Program $0$ aborts and $1$ skips.  Tests
are embedded implicitly into programs. They are meant to hold in some
states of a program and fail in others; $p\alpha$ ($\alpha p$)
restricts the execution of program $\alpha$ in its input (output) to
those states where test $p$ holds. The ordering $\le$ is the opposite
of the refinement ordering on programs (see Section~\ref{sec:refine}).

Binary relations of type $\Pow\, (S\times S)$ form
$\KAT$s~\cite{Kozen97} when $\cdot$ is interpreted as relational
composition, $+$ as relational union, $(-)^\ast$ as
reflexive-transitive closure and the elements of $B$ as
subidentities---relations below the relational unit. This grounds
$\KAT$ within standard relational imperative program semantics. Yet we
prefer the isomorphic representation as \emph{state transformers} of
type $S\to \Pow\, S$.  Composition $\cdot$ is then interpreted as
Kleisli composition
\begin{equation*} 
(f\circ_K g)\, x = \bigcup\{g\, y\mid y \in f\ x \}, 
\end{equation*} 
$0$ as $\lambda x.\ \emptyset$ and $1$ as $\eta_S = \{-\}$.  Stars
$f^{\ast}\, s  = \bigcup_{i\in\mathbb{N}} f^i\, s$ are defined with
  respect to Kleisli composition using $f^{0} = \eta_S$ and
  $f^{n+1} = f \circ_K f^{n}$. The boolean algebra of tests has
  carrier set $B_S=\{f:S\to \Pow\, S \mid f\le \eta_S\}$, where the
  order on functions has been extended pointwise,  and complementation
  is given by
  \begin{equation*} 
    \overline{f}\, x =
  \begin{cases}
    \eta_S\, x, & \text{ if } f\, x = \emptyset,\\
\emptyset, & \text{ otherwise}.
  \end{cases}
\end{equation*}
We freely identify predicates, sets and state 
transformers below $\eta_S$, which are isomorphic:
$P\cong \{s\mid P\, s\}\cong \lambda s.\ \{x\mid x=s \land P\, s\}$.

\begin{proposition}\label{P:kleisli-ka}
$\sta\, S = ((\Pow\, S)^S,B_S,\cup,\circ_K,\lambda x.\
  \emptyset, \eta_S,(-)^{\ast},\overline{(-)})$
  forms a $\KAT$, the \emph{full state transformer $\KAT$} over the
  set $S$.
\end{proposition}
A \emph{state transformer $\KAT$} over $S$ is any subalgebra of
$\sta\, S$. 

We have already formalised $\KAT$ via type classes in
Isabelle~\cite{afp:kat}.  These allow only one type parameter. Hence
we use an alternative approach that expands a Kleene algebra $K$ by an
\emph{antitest} function $n:K\to K$ from which a \emph{test} function
$t:K\to K$ is defined as $t=n^2$. Then
$K_t = \{\alpha \mid t\, \alpha = \alpha\}$ forms a boolean algebra in
which $n$ acts as test complementation. It can be used in place of the
boolean algebra $B$.  A formalisation of the state transformer model
of $\KAT$ is a contribution to this article.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Propositional Hoare Logic and Invariants}\label{sec:hl-invariants}

$\KAT$ provides a simple algebraic semantics for while
programs with
\begin{align*}
  \IF{p}{\alpha}{\beta} = p\cdot \alpha + \bar p \cdot
  \beta\qquad\text{ and }\qquad
\WHILE{p}{\alpha} = (p\cdot \alpha)^\ast \cdot \bar p.
\end{align*}
It captures validity of Hoare triples in
a partial correctness semantics as
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow p\alpha\neg q = 0,
\end{equation*}
or equivalently by $p\alpha\le \alpha q$ or $p\alpha = p\alpha q$. It
also allows deriving the rules of \emph{propositional Hoare
  logic}~\cite{Kozen00}---disregarding assignments---which are useful for
verification condition generation:
\begin{align}
  &\{p\}\, \sskip\, \{p\}, \label{eq:h-skip}\tag{h-skip}\\
  p\le p' \land \{p'\}\, \alpha\, \{q'\} \land q'\le q\ \rightarrow\ &
                                                                       \{p\}\,
                                                                       \alpha\,
                                                                       \{q\},\label{eq:h-cons}\tag{h-cons}\\
  \{p\}\, \alpha\, \{r\} \land \{r\}\, \beta\, \{q\}\ \rightarrow\
  &\{p\}\, \alpha\beta\, \{q\},\label{eq:h-seq}\tag{h-seq}\\
  \{tp\}\, \alpha\, \{q\}\land \{\neg tp\}\, \beta\, \{q\}\
  \rightarrow\ & \{p\}\, \IF{t}{\alpha}{\beta}\, \{q\},\label{eq:h-cond}\tag{h-cond}\\
  \{tp\}\, \alpha\, \{p\}\ \rightarrow\ & \{p\}\, \WHILE{t}{\alpha}\, \{\neg tp\}.\label{eq:h-while}\tag{h-while}
\end{align}

Rules for commands with invariant assertions $\alpha\ \mathbf{inv}\ i$
are derivable, too (operationally,
$\alpha\, \mathbf{inv}\, i = \alpha$).  An \emph{invariant} for
$\alpha\in K$ is a test $i\in B$ satisfying $\{i\}\, \alpha\, \{i\}$.
Then, with $\mathbf{loop}\, \alpha$ as syntactic sugar for
$\alpha^\ast$, we obtain
\begin{align}
  p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\
  &\{p\}\, \alpha\, \{q\},\label{eq:h-inv}\tag{h-inv}\\
  \{i\}\, \alpha\, \{i\} \land \{j\}\, \alpha\, \{j\}\rightarrow\
  &\{i\cdot j\}\, \alpha\, \{i\cdot j\},\label{eq:h-inv-mult}\tag{h-inv-mult}\\
  \{i\}\, \alpha\, \{i\} \land \{j\}\, \alpha\, \{j\}\rightarrow\
  &\{i+ j\}\, \alpha\, \{i+ j\},\label{eq:h-inv-plus}\tag{h-inv-plus}\\
  p \le i \wedge \{it\}\, \alpha\, \{i\} \wedge \neg t i\le q\
  \rightarrow \ & \{p\}\, \WHILEI{t}{i}{\alpha}\,  \{q\},\label{eq:h-while-inv}\tag{h-while-inv}\\
   p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\ &
                                                                   \{p\}\, \mathbf{loop}\, \alpha\,
    \mathbf{inv}\, i\, \{q\}. \label{eq:h-loop-inv}\tag{h-loop-inv}
\end{align}
We use (\ref{eq:h-inv}) for invariants for continuous
evolutions of hybrid systems in Section~\ref{sec:hoare-inv}-\ref{sec:from-flows}. The rules (\ref{eq:h-inv-mult}) and (\ref{eq:h-inv-plus}) are part of a procedure, described in Section~\ref{sec:hoare-inv}. Rule (\ref{eq:h-while-inv})
is standard for  invariants for while loops;
(\ref{eq:h-loop-inv}) is specific to loops of hybrid programs (see
Section~\ref{sec:sta-hybrid}).

The rules for propositional Hoare logic in Isabelle have been derived
for $\KAT$ in~\cite{afp:kat,afp:vericomp}. The rules for invariants
have been developed specifically for this article.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{State Transformer Semantics for Hybrid
  Programs}\label{sec:sta-hybrid}


Hybrid programs of differential dynamic logic ($\dL$)~\cite{Platzer18}
are defined by the syntax
\begin{equation*}
\mathcal{C}\ ::= \ x:=e \mid x' = f \, \&\, G \mid ?P\mid \mathcal{C};\mathcal{C}\mid \mathcal{C}+\mathcal{C}\mid \mathcal{C}^*
\end{equation*}
that adds \emph{evolution commands} $x' = f \, \&\, G$ to the language
of $\KAT$---function $?(-)$ embeds tests explicitly into programs.
Evolution commands introduce a time independent vector field $f$ for
an autonomous system of ordinary differential equations
(ODEs)~\cite{Teschl12} together with a guard $G$, a predicate
modelling boundary conditions or similar restrictions on temporal
evolutions. % Guards are also known as \emph{evolution domain
  % restrictions}~\cite{DoyenFPP18}.

Formally, we fix a state space $S$ of the hybrid program, for example
$S\subseteq \reals^n$ and $n\in\mathbb{N}$. Continuous variables are
characterised algebraically using lenses~\cite{FosterZW16}, to support
several state space models. A lens, $x : A \lto S$, is a quadruple
$x \defs (A, S, \lget, \lput)$, where $A$ is the variable type, and
$S$ is the state space. Total functions $\lget_x : S \to A$ and
$\lput_x : S \to A \to S$ query and update the value of $x$ in a
particular state. They are linked by three intuitive
algebraic laws~\cite{FosterZW16}: 
$$\lget~(\lput~s~v) = v \qquad \lput~(\lput~s~v')~v = \lput~s~v \qquad \lput~s~(\lget~s) = s$$
where $s \in S$ and $v, v' \in V$. Lenses $x$ and $y$ can also be
checked for independence using the predicate $x \lindep y$, which
allows us to distinguish variables. Each continuous variable is a
lens, $x : \reals \lto S$. If $S \subseteq \reals^n$, then there are
$n$ independent lenses, $x_1 \cdots x_n$, that each corresponds to a
projection from $\reals^n$. However, this is not the only possible
state space, and more complex state space models --- such as matrices,
or infinite Euclidean spaces -- can be supported as well.

Systems of equations are modelled using vector fields: functions of
type $S\to S$ on some open set $S$. Geometrically, vector field $f$
assigns a vector to any point of the state space $S$. A solution to
the \emph{initial value problem} (IVP) for the pair $(f,s)$ and
initial value $(0,s)\in T\times S$, where $T$ is an open interval in
$\reals$ containing $0$, is then a function $X:T\to S$ that satisfies
$X'\, t = f\, (X\, t)$---an autonomous system of ODEs in vector
form---and $X\, 0 = s$. Solution $X$ is thus a curve in $S$ through
$s$, parametrised in $T$ and tangential to $f$ at any point in $S$; it
is called \emph{trajectory} or \emph{integral curve} of $f$ at $s$
whenever it is uniquely defined ~\cite{Teschl12}.

For IVP $(f,s)$ with continuous vector field $f:S\to S$ and initial
state $s\in S$ we define the set of solutions on
$T$ as
\begin{equation*}
\Sols f\, T\, s = \left\{X \mid \forall t\in T.\  X'\, t = f\, (X\, t)\land X\, 0 = s\right\}.
\end{equation*}
Each solution $X$ is then continuously differentiable and thus
$f\circ X$ integrable in $T$.  For $X\in \Sols\, f\, T\, s$ and
$G:S\to\bools$, we further define the $G$-\emph{guarded orbit} of $X$
along $T$ in $s$~\cite{MuniveS19} with the help of the state transformer
$\gamma^X_G:S\to \Pow\, S$ as 
\begin{equation*}
\gamma^X_{G}\, s= \left\{X\, t\mid t\in T\land \forall \tau\in
{\downarrow}t.\ G\, (X\, \tau)\right\},
\end{equation*}
where ${\downarrow}t = \left\{t'\in T\mid t'\le t\right\}$, and the
$G$-\emph{guarded orbital} of $f$ along $T$ in $s$~\cite{MuniveS19}
via the state transformer $\gamma^f_G:S\to \Pow\, S$ as
\begin{equation*}
  \gamma^f_G\ s = \bigcup\left\{\gamma^X_G\, s\mid X\in \Sols\, f\, T\, s\right\}.
\end{equation*}
In applications, ${\downarrow}t$ is usually an interval
$[0,t]\subseteq T$.  Expanding definitions,
\begin{equation*}
\gamma^f_G\, s = \left\{X\, t \mid X\in \Sols\, f\, T\, s \land t\in T
\land \forall \tau\in{\downarrow}t.\ G\, (X\, \tau)\right\}.
\end{equation*}
If $\top$ denotes the predicate that holds of all states in $S$ (or
the set $S$ itself), we write $\gamma^f$ instead of
$\gamma^f_\top$. We define the semantics of the evolution command
$x'= f\, \&\, G$~\cite{MuniveS19} for any continuous $f:S\to S$ and
$G:S\to \bools$ as
\begin{equation}
{\left(x'= f\, \&\, G\right)} = \gamma^f_G.\label{eq:st-evl}\tag{st-evl}
\end{equation}

Defining the state transformer semantics of assignments is
standard~\cite{MuniveS19}, though we generalise using lenses. First,
we use lenses to define state updates:
$$\sigma(x\mapsto e) \defs \lambda s : S.\, \lput_x ~ (\sigma(s)) ~ (e(s))$$
for $x : V \lto S$, $e : S \to V$, and $\sigma : S \to
S$. Intuitively, this updates the value of variable $x$ in the state
transformer $\sigma : S \to S$ to have the value given by $e$. Here, the
function $e$ is used to model an ``expression'' that is evaluated in
the context of the state $s$. Then we define a generalised assignment operator:

\begin{equation}
  \langle \sigma \rangle \defs \lambda s. \{ \sigma(s) \} \tag{st-assgn}
\end{equation}
%
This applies the function $\sigma : S \to S$ as an assignment. With
our state update function, singleton assignment is simply a special
case: $x := e \defs \langle id(x \mapsto e) \rangle$, where
$id \defs \lambda s. s$, and we can also describe simultaneous updates
by assigning several variables at once. With this foundation, we can
also prove the standard laws of assignment in this setting:
%
\begin{align*}
  x := x &~=~ \sskip \\
  x := e \seq x := f &~=~ x := f[e/x] \\
  x := e \seq y := f &~=~ y := f \seq x := e & \textnormal{provided~} x \lindep y, x \unrest f, y \unrest e
\end{align*}

Here, $x \unrest e$ means that the semantic expression $e$ does not
depend for its valuation on lens $x$~\cite{FosterZW16}. An assignment
of $x$ to itself is simply $\sskip$. Two assignments to $x$ result in
a single assignment, with a semantic substitution applied. Assignments
to independent variables $x$ and $y$ commute provided that neither
assigned expression depend on the corresponding variable.

% First we define a state update function
% $f_a:V\to (S \to E) \to S\to S$ as
% \begin{equation*}
% f_a\, x\, e\, s = s[x\mapsto e\, s],
% \end{equation*}
% where $f[a\mapsto b]$ updates $f:A\to B$ by associating $a\in A$ with
% $b$ and every $y\neq a$ with $f\, y$.  The ``expression''
% ${e:S\to \reals}$ is thus evaluated in state $s$ to $e\, s$.  Then we
% lift $f_a\, x\, e:S\to S$ to state transformer
% $x:= e:S \to \Pow\, S$ using $\eta_S$:
% \begin{equation}
%   (x:= e) = \lambda s.\ \{f_a\, x\, e\, s\}.\label{eq:st-assgn}\tag{st-assgn}
% \end{equation}

The development in this section has already been formalised with
Isabelle~\cite{afp:hybrid}, both for a state transformer and a
relational semantics. An instance of the latter for particular vector
fields with unique solutions forms the standard semantics of
$\dL$. Due to the connection to orbits or orbitals, the state
transformer semantics is arguably conceptually simpler and more
elegant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Differential Hoare Logic for Flows}\label{sec:hoare-flow}

\gin{we need to discuss hybrid semantics of hoare triples in detail
  --- how do they work?}

The assignment axiom of Hoare logic need not be explained. Our concrete
semantics yields a variant with update functions instead
of substitutions:
\begin{equation}
\left\{\lambda s.\ P\, s[x\mapsto e\, s]\right\}\,  x:=e\, \{P\}. \label{eq:h-assgn}\tag{h-assgn}
\end{equation}
Hence all we need to add to Hoare logic is a rule for evolution
commands.  We restrict our attention to Lipschitz-continuous vector
fields for which unique solutions to IVPs are guaranteed by
Picard-Lindel\"of's theorem~\cite{Teschl12}.  These are \emph{(local)\
  flows} $\flow:T\to S\to S$ and $X=\flow_s=\lambda t.\ \flow\, t\, s$
is the trajectory at $s$. Guarded orbitals $\gamma^f_G$ then
specialise to \emph{guarded orbits}
\begin{equation*}
  \gamma^f_{G,U} = \left\{\flow_s\, t\mid t\in U\land \forall\tau \in
  {\downarrow}t.\ G\, (\flow_s\, t)\right\},
\end{equation*}
where $U\subseteq T$ is a time domain of interest, typically an
interval $[0,t]$ for some $t\in T$~\cite{MuniveS19}.  Accordingly,
(\ref{eq:st-evl}) becomes
\begin{equation}
  \left(x' = f\, \&\, G\right)= \gamma^f_{G,U}.\label{eq:st-evl-flow}\tag{st-evl-flow}
\end{equation}
The following Hoare-style rule for evolution commands is then
derivable.
\begin{lemma}\label{P:h-evl-lemma}
  Let $f:S\to S$ be a Lipschitz continuous vector field on
  $S\subseteq \reals^n$ and $\flow:T\to S\to S$ its local flow with
  $0\in T\subseteq \reals$. Then, for $U\subseteq T$ and
  $G,Q:S\to\bools$,
\begin{equation}
\left\{\lambda s\in S.\forall t\in U.\ \left(\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)\right) \rightarrow Q\,
(\flow_s\, t)\right\}\, x' = f\, \&\, G\, \{Q\}. \label{eq:h-evl}\tag{h-evl}
\end{equation}
\end{lemma}

This finishes the derivation of rules for a Hoare logic $\dH$ for
hybrid programs---to our knowledge, the first Hoare logic of this
kind. As usual, there is one rule per programming construct, so that
their recursive application generates proof obligations that are
entirely about data-level relationships---the discrete and continuous
evolution of hybrid program stores.

The rule~(\ref{eq:h-evl}) supports the following procedure
for reasoning with an evolution command $x' = f\, \&\, G$ and set $U$
in this calculus:
\begin{enumerate}
\item Check that vector field $f$ satisfies the conditions for
  Picard-Lindel\"of's theorem ($f$ is Lipschitz continuous and
  $S\subseteq\reals^n$ is open).
\item Supply a (local) flow $\flow$ for $f$ with open interval of
  existence $T$ around $0$.
\item Check that $\flow_s$ solves the IVP $(f,s)$ for each $s\in S$;
  that is, $\flow_s'\, t = f\, (\flow_s\, t)$, $\flow_s\, 0 = s$, and
  $U\subseteq T$.
\item If successful, apply rule~(\ref{eq:h-evl}).
\end{enumerate}

\begin{example}[Thermostat verification via solutions]\label{ex:therm-sol}
A thermostat uses variable $T_0$ to store an initial temperature and $\Theta$ to indicate wether the heater is switched on or off. Variable $T$ denotes the room's temperature and $t$ is time. At most every $\tau$ minutes, the thermostat sets its chronometer to $0$, measures 
the room's temperature, and turns the heater on (or off) according to this measurement. A hybrid program to model this behaviour is
\begin{align*}
	\mathsf{Cntrl} = &\ {t:=(\lambda\, s.\ 0)};{T_0:=(\lambda\, s.\ s_T)};\\
				&\ \IF {(\lambda\, s.\ s_\Theta=0 \land s_{T0}\leq T_{min} + 1)} {\Theta:=(\lambda\, s.\ 1)} {}\\
				&\ \IF {(\lambda\, s.\ s_\Theta=1 \land s_{T0}\geq T_{max} - 1)} {\Theta:=(\lambda\, s.\ 0)} {\mathit{skip}},\\
	\mathsf{Dyn} = &\ \IF {(\lambda\, s.\ s_\Theta=0)} {x' = f_0\, \&\, G_0} {x' = f_L\, \&\, G_L},\\
	\mathsf{Thermostat} = &\ (\mathsf{Cntrl}{;}\mathsf{Dyn})^\ast,
\end{align*}
where $s_v=s\, v$ for $v\in\{T,t,T_0,\Theta\}$. We also assume $0<T_{min}$, $T_{max}<L$, $a>0$, $U=[0,\tau]$ and use vector fields and guards for $c\in\{0,L\}$
\begin{align*}
f_c\, (s_T,s_t, s_{T0}, s_\Theta)^\top &= (-a(s_T-c),1,0,0)^\top\\
G_c\, s  &= \left(s_t\leq -\frac{1}{a}\ln\left(\frac{c-\Delta_c}{c-s_{T0}}\right)\right),
\end{align*}
% \begin{equation*}
%    f_c\,
%    \begin{pmatrix}
%      s_T\\
%      s_t\\
%	s_{T0}\\
%	s_\Theta
%    \end{pmatrix}
%=
%\begin{pmatrix}
%  -a(s_T-c)\\
%  1\\
%  0\\
%  0\\
%\end{pmatrix}\quad\text{and}\quad
%G_c\, s = \left(s_t\leq -\frac{1}{a}\ln\left(\frac{c-\Delta_c}{c-s_m}\right)\right),
%\end{equation*}
where $\Delta_c=T_{min}$ if $c=0$ and $\Delta_c = T_{max}$ if $c=L$. Its correctness specification is $\{I\}\, \mathsf{Thermostat}\, \{I\}$ where $I\, s=\left(T_{min}\leq s_T\leq T_{max}\land (s_\Theta = 1 \lor s_\Theta=0)\right)$.

We use Isabelle's real valued vectors $s{\isacharcolon}{\isacharcolon}\mathit{real}{\isacharcircum}4$ for our hybrid store. The notation $s{\isachardollar}i$ represents the $i$th coordinate of a vector $s$ and
hence the value of store $s$ at variable $i$. In Isabelle, we use \isa{{\isadigit{1}}}, \isa{{\isadigit{2}}}, \isa{{\isadigit{3}}}, and \isa{{\isadigit{4}}} for $T$, $t$, $T_0$ and $\Theta$ respectively, and denote Hoare triples with \isa{Hoare\ {\isasymlceil}{\isacharminus}{\isasymrceil}\isacharminus{\isasymlceil}{\isacharminus}{\isasymrceil}}. For resemblance of program syntax, we also use a semicolon (\isa{{\isacharsemicolon}}) instead of a dot $(\cdot)$ for multiplication in $\KAT$. Thus, the formalisation of the correctness specification for $\mathsf{Thermostat}$ is

\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ thermostat{\isacharunderscore}flow{\isacharcolon}\ \isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ a{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ Tmin{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}Tmax\ {\isacharless}\ L{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Hoare\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\isanewline
\ \ {\isacharparenleft}LOOP\ {\isacharparenleft}\isanewline
\ \ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ \ {\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\ {\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymle}\ Tmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ ELSE\isanewline
\ \ \ \ \ IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymge}\ Tmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ a\ {\isadigit{0}}\ {\isacharampersand}\ G\ Tmin\ Tmax\ a\ {\isadigit{0}}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}\ \isanewline
\ \ \ \ ELSE\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ a\ L\ {\isacharampersand}\ G\ Tmin\ Tmax\ a\ L\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}\isanewline
\ \ {\isacharparenright}\ INV\ I\ Tmin\ Tmax{\isacharparenright}\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}{\isachardoublequoteclose}\isanewline
\isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ H{\isacharunderscore}loopI{\isacharparenright}\isanewline
\ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule{\isacharunderscore}tac\ R{\isacharequal}{\isachardoublequoteopen}{\isasymlambda}s{\isachardot}\ I\ Tmin\ Tmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}{\isacharequal}{\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isachardoublequoteclose}\ \isakeyword{in}\ H{\isacharunderscore}seq{\isacharparenright}\isanewline
\ \ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule{\isacharunderscore}tac\ R{\isacharequal}{\isachardoublequoteopen}{\isasymlambda}s{\isachardot}\ I\ Tmin\ Tmax\ s{\isasymand}\ s{\isachardollar}{\isadigit{2}}{\isacharequal}{\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isachardoublequoteclose}\ \isakeyword{in}\ H{\isacharunderscore}seq{\isacharparenright}\isanewline
\ \ \ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule{\isacharunderscore}tac\ R{\isacharequal}{\isachardoublequoteopen}{\isasymlambda}s{\isachardot}\ I\ Tmin\ Tmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}{\isacharequal}{\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{in}\ H{\isacharunderscore}seq{\isacharcomma}\ simp{\isacharcomma}\ simp{\isacharparenright}\isanewline
\ \ \ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ H{\isacharunderscore}cond{\isacharcomma}\ simp{\isacharunderscore}all\ add{\isacharcolon}\ H{\isacharunderscore}g{\isacharunderscore}ode{\isacharunderscore}therm{\isacharbrackleft}OF\ assms{\isacharparenleft}{\isadigit{1}}{\isacharcomma}{\isadigit{2}}{\isacharparenright}{\isacharbrackright}{\isacharparenright}{\isacharplus}\isanewline
\ \ \isacommand{using}\isamarkupfalse%
\ therm{\isacharunderscore}dyn{\isacharunderscore}up{\isacharunderscore}real{\isacharunderscore }arith{\isacharbrackleft}OF\ assms{\isacharparenleft}{\isadigit{1}}{\isacharparenright}\ {\isacharunderscore}\ {\isacharunderscore}\ assms{\isacharparenleft}{\isadigit{4}}{\isacharparenright}{\isacharcomma}\ of\ Tmin{\isacharbrackright}\isanewline
\ \ \ \ \isakeyword{and}\ therm{\isacharunderscore}dyn{\isacharunderscore}down{\isacharunderscore }real{\isacharunderscore}arith{\isacharbrackleft}OF\ assms{\isacharparenleft}{\isadigit{1}}{\isacharcomma}{\isadigit{3}}{\isacharparenright}{\isacharcomma}\ of\ {\isacharunderscore}\ Tmax{\isacharbrackright}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\end{isabellebody}

The rule applications decompose the program structure of $\mathsf{Thermostat}$. The first line applies rule (\ref{eq:h-loop-inv}) while the next three lines do the same with (\ref{eq:h-seq}) and correspond reversely to the three semicolons in the program structure. The fifth line reasons with the conditional and evolution commands by constantly applying (\ref{eq:h-cond}) followed by a simplification using (\ref{eq:h-evl}) until it is not possible to do so any more. This is successful because lemma \isa{H{\isacharunderscore}g{\isacharunderscore}ode{\isacharunderscore}therm} includes the fact that the flow for $f_c$ is  
\begin{equation*}
\flow\, \tau\, s = (-e^{-a\cdot\tau}\cdot(c-s_T)+c, \tau+s_t, s_{T0}, s_\Theta)^\top,
%	\begin{pmatrix}
%      -e^{-a\cdot\tau}\cdot(c-s_T)+c\\
%      \tau+s_t\\
%	s_m\\
%	s_b
%    \end{pmatrix},
\end{equation*}
%\begin{isabellebody}
%\isacommand{abbreviation}\isamarkupfalse%
%\ therm{\isacharunderscore}flow\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}real\ {\isasymRightarrow}\ real\ {\isasymRightarrow}\ real\ {\isasymRightarrow}\ real{\isacharcircum}{\isadigit{4}}\ {\isasymRightarrow}\ real{\isacharcircum}{\isadigit{4}}{\isachardoublequoteclose}\ {\isacharparenleft}{\isachardoublequoteopen}{\isasymphi}{\isachardoublequoteclose}{\isacharparenright}\isanewline
%\ \ \isakeyword{where}\ {\isachardoublequoteopen}{\isasymphi}\ a\ L\ {\isasymtau}\ s\ {\isasymequiv}\ {\isacharparenleft}{\isasymchi}\ i{\isachardot}\ if\ i\ {\isacharequal}\ {\isadigit{1}}\ then\ {\isacharminus}\ exp{\isacharparenleft}{\isacharminus}a\ {\isacharasterisk}\ {\isasymtau}{\isacharparenright}\ {\isacharasterisk}\ {\isacharparenleft}L\ {\isacharminus}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}\ {\isacharplus}\ L\ else\ \isanewline
%\ \ {\isacharparenleft}if\ i\ {\isacharequal}\ {\isadigit{2}}\ then\ {\isasymtau}\ {\isacharplus}\ s{\isachardollar}{\isadigit{2}}\ else\ s{\isachardollar}i{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
%\isanewline
%\end{isabellebody}


for all $\tau\in\reals$. The remaining proof obligations are inequalities of exponentials and logarithms, which are discharged by supplying auxiliary lemmas to Isabelle's \isa{auto} method. \qed
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Differential Hoare Logic for Invariants}\label{sec:hoare-inv}

Alternatively, $\dH$ supports reasoning with invariants for evolution
commands instead of supplying flows to~(\ref{eq:h-evl}).  The approach
has been developed in~\cite{MuniveS19}. Our invariants generalise the
\emph{differential invariants} of $\dL$~\cite{Platzer18} and the
\emph{invariant sets} of dynamical systems and (semi)group
theory~\cite{Teschl12} .

A predicate $I:S\to\bools$ is an \emph{invariant} of the continuous
vector field $f:S\to S$ and guard $G:S\to\bools$ \emph{along}
$T\subseteq \reals$ if
\begin{equation*}
\bigcup \Pow\, \gamma^f_G\, I\subseteq  I.
\end{equation*}
The operation $\bigcup\circ\Pow$ is the Kleisli extension $(-)^\dagger$
in the powerset monad. Hence we could simply write
$(\gamma^f_G)^\dagger\, I \subseteq I$. The definition of invariance
unfolds to
\begin{equation*}
  \forall s.\ I\, s \to (\forall X\in\Sols f\, T\, s.\forall t\in T.\ (\forall \tau\in {\downarrow}t.\ G\, (X\, \tau)) \to I\, (X\, t)).
\end{equation*}
For $G=\top$ we call $I$ an \emph{invariant} of $f$ along $T$.
Intuitively, invariants can be seen as sets of orbits.

Invariants for evolution commands are coherent with those in Section~\ref{sec:hl-invariants}.
\begin{proposition}\label{P:inv-prop}
  Let $f:S\to S$ be continuous, $G:S\to\bools$ and
  $T\subseteq \reals$. Then $I$ is an invariant for $f$ and $G$ \emph{along} $T$ if and only if
$ \{I\}\, x' = f\, \&\, G\, \{I\}$.
\end{proposition}
Hence we can use a variant of (\ref{eq:h-inv}) for verification condition generation:
\begin{align}
  P\le I \land \{I\}\, x' = f\, \&\, G\, \{I\}\land (I\cdot G)\le Q\ \rightarrow\
  &\{P\}\, x' = f\, \&\, G\, \{Q\}.\label{eq:h-invg}\tag{h-invg}
\end{align}
It remains to check invariance in the antecedent of this rule. The
following lemma leads to a procedure.

\begin{lemma}[\cite{MuniveS19}]\label{P:invrules}
  Let $f:S\to S$ be a continuous vector field, $\mu,\nu:S\to\reals$
  differentiable and $T\subseteq \reals$. 
\begin{enumerate}
\item If $(\mu\circ X)' =(\nu\circ X)'$ for all
  $X\in \Sols f\, T\, s$, then $\{\mu=\nu\}\, x' = f\, \&\, G\, \{\mu=\nu\}$, 
\item if $(\mu\circ X)'\, t\leq(\nu\circ X)'\, t$ when $t> 0$, and $(\mu\circ X)'\, t\geq(\nu\circ X)'\, t$ when $t< 0$, for all $X\in \Sols f\, T\, s$,
  then $\{\mu <\nu\}\, x' = f\, \&\, G\, \{\mu <\nu\}$
\item $\mu\neq \nu$ if and only if $\mu < \nu$ or $\nu < \mu$,
\item $\mu \not\le \nu$ if and only if $\nu < \mu$.
\end{enumerate}
\end{lemma}

Condition $(1)$ follows from the well known fact that two continuously
differentiable functions are equal if they intersect at some point and their
derivatives are equal. Therefore, rules (\ref{eq:h-invg}), (\ref{eq:h-inv-mult}), (\ref{eq:h-inv-plus}),
Proposition~\ref{P:inv-prop} and Lemma~\ref{P:invrules} yield the following procedure for verifying a triple $\{P\}\, x' = f\, \&\, G\, \{Q\}$
using an invariant.
\begin{enumerate}
\item Check whether a candidate predicate $I$ is an invariant for $f$
  along $T$:
	\begin{enumerate}
	\item transform $I$ into negation normal form;
	\item reduce $I$ (if complex) with (\ref{eq:h-inv-mult}), (\ref{eq:h-inv-plus}) and Lemma~\ref{P:invrules} (3,4);
	\item if $I$ is atomic, apply Lemma~\ref{P:invrules} (1) and (2);
	\end{enumerate}
(if successful,  $\{I\}\, x' = f\, \&\, G\, \{I\}$ holds by Proposition~\ref{P:inv-prop}),
\item if successful, prove $P\le I$ and $(I\cdot G)\le Q$ to apply rule (\ref{eq:h-invg}).
\end{enumerate}

\begin{example}[Water tank verification via invariants]\label{ex:tank-inv}
A controller turns on and off a water pump to keep the level of water $h$ in a tank within a safe region $h_{min}\leq h\leq h_{max}$. As in Example~\ref{ex:therm-sol}, we use $t$ for time, $h_0$ for water-level measurements and $\Pi$ for indicating whether the pump is on or off. A hybrid program to model the controller and the water level in the tank, where we abbreviate $s_v=s\, v$ for $v\in\{h,t,h_0,\Pi\}$, is
\begin{align*}
	\mathsf{Cntrl} = &\ {t:=(\lambda\, s.\ 0)};{h_0:=(\lambda\, s.\ s_h)};\\
				&\ \IF {(\lambda\, s.\ s_\Pi=0 \land s_{h0}\leq h_{min} + 1)} {\Pi:=(\lambda\, s.\ 1)} {}\\
				&\ \IF {(\lambda\, s.\ s_\Pi=1 \land s_{h0}\geq h_{max} - 1)} {\Pi:=(\lambda\, s.\ 0)} {\mathit{skip}},\\
	\mathsf{Dyn} = &\ \IF {(\lambda\, s.\ s_\Pi=0)} {x' = f_{c_i-c_o}\, \&\, G_{c_i-c_o}} {x' = f_{-c_o}\, \&\, G_{-c_o}},\\
	\mathsf{Tank} = &\ (\mathsf{Cntrl}{;}\mathsf{Dyn})^\ast.
\end{align*}
Here, for $k\in\{-c_o,c_i-c_o\}$ we just need to assume that
\begin{equation*}
	f_k\, (s_h,s_t,s_{h0},s_\Pi)^\top = (k, 1, 0, 0)^\top\text{ and }
	G_k\, s = \left(s_t\leq \frac{\Delta_k-s_{h0}}{k}\right),
%    \begin{pmatrix}
%      s_h\\
%      s_t\\
%	s_{h0}\\
%	s_b
%    \end{pmatrix}
%=
%\begin{pmatrix}
%  k\\
%  1\\
%  0\\
%  0\\
%\end{pmatrix}\quad\text{and}\quad
\end{equation*}
where $0 < c_o$, $c_o < c_i$, and $\Delta_k=h_{min}$ if $k=-c_o$ and
$\Delta_k = h_{max}$ if $k=c_i-c_o$. We need to prove the
specification $\{I\}\, \mathsf{Tank}\, \{I\}$ where
$I\, s=\left(h_{min}\leq s_h\leq h_{max}\land (s_\Pi = 1 \lor
  s_\Pi=0)\right)$. For this we use an invariant for $f_k$:
\begin{equation*}
dI_k\, s = \left(s_h=ks_t+s_{h0}\land 0\leq s_t\land h_{min}\leq s_{h0}\leq h_{max} \land (s_\Pi=0\lor s_\Pi=1)\right).
\end{equation*}

As before, in Isabelle we use \isa{{\isadigit{1}}}, \isa{{\isadigit{2}}}, \isa{{\isadigit{3}}}, and \isa{{\isadigit{4}}} for $h$, $t$, $h_0$ and $\Pi$ respectively, but for this example we use the invariant annotated version of evolution commands, which means that our formalisation for $\{I\}\, \mathsf{Tank}\, \{I\}$ is
\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ tank{\isacharunderscore}inv{\isacharcolon}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ c\isactrlsub o{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}c\isactrlsub o\ {\isacharless}\ c\isactrlsub i{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Hoare\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ \ {\isacharparenleft}{\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}{\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymle}\ Hmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ ELSE\ \isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymge}\ Hmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ {\isacharparenleft}c\isactrlsub i{\isacharminus}c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ G\ Hmax\ {\isacharparenleft}c\isactrlsub i{\isacharminus}c\isactrlsub o{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline 
\ \ \ \ \ \ DINV\ {\isacharparenleft}dI\ Hmin\ Hmax\ {\isacharparenleft}c\isactrlsub i{\isacharminus}c\isactrlsub o{\isacharparenright}{\isacharparenright}{\isacharparenright}\ ELSE\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ {\isacharparenleft}{\isacharminus}c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ G\ Hmin\ {\isacharparenleft}{\isacharminus}c\isactrlsub o{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline 
\ \ \ \ \ \ DINV\ {\isacharparenleft}dI\ Hmin\ Hmax\ {\isacharparenleft}{\isacharminus}c\isactrlsub o{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isacharparenright}\ {\isacharparenright}\isanewline
\ \ INV\ I\ Hmin\ Hmax{\isacharparenright}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}{\isachardoublequoteclose}\isanewline
\isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ H{\isacharunderscore}loopI{\isacharparenright}\isanewline
\ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule{\isacharunderscore}tac\ R{\isacharequal}{\isachardoublequoteopen}{\isasymlambda}s{\isachardot}\ I\ Hmin\ Hmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}{\isacharequal}{\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isachardoublequoteclose}\ \isakeyword{in}\ H{\isacharunderscore}seq{\isacharparenright}\isanewline
\ \ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule{\isacharunderscore}tac\ R{\isacharequal}{\isachardoublequoteopen}{\isasymlambda}s{\isachardot}\ I\ Hmin\ Hmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}{\isacharequal}{\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isachardoublequoteclose}\ \isakeyword{in}\ H{\isacharunderscore}seq{\isacharparenright}\isanewline
\ \ \ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule{\isacharunderscore}tac\ R{\isacharequal}{\isachardoublequoteopen}{\isasymlambda}s{\isachardot}\ I\ Hmin\ Hmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}{\isacharequal}{\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{in}\ H{\isacharunderscore}seq{\isacharcomma}\ simp{\isacharcomma}\ simp{\isacharparenright}\isanewline
\ \ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ H{\isacharunderscore}cond{\isacharcomma}\ simp{\isacharcomma}\ simp{\isacharparenright}{\isacharplus}\isanewline
\ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ H{\isacharunderscore}cond{\isacharcomma}\ rule\ H{\isacharunderscore}g{\isacharunderscore}ode{\isacharunderscore}inv{\isacharparenright}\isanewline
\ \ \isacommand{using}\isamarkupfalse%
\ assms\ tank{\isacharunderscore}inv{\isacharunderscore}arith{\isadigit{1}}\ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}force\ simp{\isacharcolon}\ tank{\isacharunderscore}diff{\isacharunderscore}inv{\isacharcomma}\ simp{\isacharcomma}\ clarsimp{\isacharparenright}\isanewline
\ \ \ \ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ H{\isacharunderscore}g{\isacharunderscore}ode{\isacharunderscore}inv{\isacharparenright}\isanewline
\ \ \isacommand{using}\isamarkupfalse%
\ assms\ tank{\isacharunderscore}diff{\isacharunderscore}inv{\isacharbrackleft}of\ {\isacharunderscore}\ {\isachardoublequoteopen}{\isacharminus}c\isactrlsub o{\isachardoublequoteclose}\ Hmin\ Hmax{\isacharbrackright}\ tank{\isacharunderscore}inv{\isacharunderscore}arith{\isadigit{2}}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\end{isabellebody}

Up to the fifth line, the proof is the same as that of $\mathsf{Thermostat}$. Then, an application of (\ref{eq:h-cond}) splits the proof obligation giving one for each evolution command. These are discharged using rule (\ref{eq:h-invg}) followed by the fact that $dI_k$ is an invariant for $f_k$ (\isa{tank{\isacharunderscore}diff{\isacharunderscore}inv}) and some arithmetical properties. \qed
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Differential Refinement Calculi}\label{sec:refine}

A \emph{refinement Kleene algebra with tests}
($\rKAT$)~\cite{ArmstrongGS16}  is a $\KAT$
$(K,B)$ expanded by an operation $[-,-]:B\times B\to K$ that
satisfies, for all $\alpha \in K$ and $p,q\in B$, 
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow \alpha\le [p,q].
\end{equation*}
The element $[p,q]$ of $K$ corresponds to Morgan's \emph{specification
  statement}~\cite{Morgan94}. It satisfies
\begin{equation*}
  \{p\}\, [p,q]\, \{q\}\qquad \text{ and }\qquad \{p\}\, \alpha\, \{q\} \rightarrow \alpha\le [p,q],
\end{equation*}
which makes $[p,q]$ the greatest element of $K$ that satisfies the Hoare
triple with precondition $p$ and postcondition $q$.  Indeed, in
$\sta\, S$ and for $S\subseteq \reals^n$,
\begin{equation*}
  [P,Q] = \bigcup \left\{f:S\to \Pow\, S \mid \{P\}\, f\, \{Q\}\right\}.
\end{equation*}

Variants of Morgan's laws~\cite{Morgan94} of a \emph{propositional
  refinement calculus}---once more ignoring assignments---are then derivable in
$\rKAT$~\cite{ArmstrongGS16}.
\begin{align}
  1 &\le [p,p],\label{eq:r-skip}\tag{r-skip}\\
[p',q'] &\le [p,q],\qquad \text{ if } p\le p'\text{ and } q'\le q,\label{eq:r-cons}\tag{r-cons}\\
[p,r]\cdot [r,q] &\le [p,q],\label{eq:r-seq}\tag{r-seq}\\
\IF{t}{[tp,q]}{[\neg tp,q]} &\le [p,q],\label{eq:r-cond}\tag{r-cond}\\
 \WHILE{t}{[tp,p]} &\le [p,\neg tp]. \label{eq:r-while}\tag{r-while}
\end{align}
For the sake of completeness, one can also derive $\alpha \le [0,1]$ and $[1,0] \le \alpha$, but we do not use them in proofs.

For invariants and loops, we obtain the additional refinement laws
\begin{align}
  [i,i] &\le [p,q],\qquad \text{ if } p\le i \le q,\label{eq:r-inv}\tag{r-inv}\\
\mathbf{loop} [i,i] &\le [i,i]. \label{eq:r-loop}\tag{r-loop}
\end{align}

In $\sta\, S$, moreover, the following assignments laws are
derivable~\cite{ArmstrongGS16}.
\begin{align}
 (x := e)  &\le  \left[\lambda s.\ Q\, s[x\mapsto e\, s],Q\right],\label{eq:r-assgn}\tag{r-assgn}\\
(x:= e) \cdot \left[Q,Q\right] &\le [\lambda s.\ Q\, s[x\mapsto e\, s],Q],\label{eq:r-assgn}\tag{r-assgnl}\\
\left[Q,\lambda s.\ Q\, s[x\mapsto e\, s]\right]\cdot (x:=e) &\le [Q,Q]. \label{eq:r-assgn}\tag{r-assgnf}
\end{align}
The second and third law are known as \emph{leading} and \emph{following}
law. They introduce an assignment before and after a block of code. 

Finally, we obtain the following refinement laws for evolution
commands.
\begin{lemma}\label{P:r-evl-lemma}
  Let $f:S\to S$ be a Lipschitz continuous vector field on
  $S\subseteq \reals^n$ and $\flow:T\to S\to S$ its local flow with
  $0\in T\subseteq \reals$. Then, for $U\subseteq T$ and
  $G,Q:S\to\bools$,
\begin{gather*}
(x' = f\, \&\, G)\, \le\, [\lambda s.\forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evl}\tag{r-evl}\\
(x' = f\, \&\, G) \cdot \left[Q,Q\right]\, \le\, [\lambda s. \forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evll}\tag{r-evll}\\
\left[Q,\lambda s. \forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\,
t)\right]\cdot (x' = f\, \&\, G) \, \le \, [Q,Q].\label{eq:r-evlr}\tag{r-evlr}
\end{gather*}
\end{lemma}

Taken together, the laws in this section form the differential
refinement calculus $\dR$.  They suffice for constructing hybrid
programs from initial specification statements by step-wise refinement
incrementally and compositionally. To our knowledge $\dR$ is the first
refinement calculus for hybrid programs of this kind.  A more powerful
variant based on predicate transformers \`a la Back and von
Wright~\cite{BackW98} has been developed in~\cite{MuniveS19}, but
applications remain to be explored.  A previous approach to refinement
for hybrid programs in $\dL$~\cite{LoosP16} is quite different to the
two standard calculi mentioned and much more intricate than the
approach presented.

\begin{example}[Thermostat refinement via solutions]\label{ex:therm-rsol}
Here we refine $\mathsf{Thermostat}$ from Example~\ref{ex:therm-sol} in a modular way. To prove $\mathsf{Thermostat}\leq [I,I]$ (in Isabelle, $\mathsf{Thermostat}\leq \isa{Ref\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}}$) we need to show that the body of the loop also refines the specification $[I,I]$. For this we prove a refinement statement for the control and one for the dynamics which we later compose. This implies ensuring that the loop invariant $I$ is a precondition of the control and a postcondition of the dynamics and that any postcondition of the control will be the precondition of the dynamics.
\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}therm{\isacharunderscore}ctrl{\isacharcolon}\isanewline
\ \ {\isachardoublequoteopen}Ref\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ I\ Tmin\ Tmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isasymrceil}\ {\isasymge}\isanewline
\ \ {\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\ {\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymle}\ Tmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ ELSE\ IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymge}\ Tmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}therm{\isacharunderscore}dyn{\isacharcolon}\isanewline
\ \isakeyword{assumes}\ {\isachardoublequoteopen}a\ {\isachargreater}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ Tmin{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}Tmax\ {\isacharless}\ L{\isachardoublequoteclose}\isanewline
\ \isakeyword{shows}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ I\ Tmin\ Tmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isasymrceil}\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymge}\ \isanewline
\ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ a\ {\isadigit{0}}\ {\isacharampersand}\ G\ Tmin\ Tmax\ a\ {\isadigit{0}}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}\ \isanewline
\ \ ELSE\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ a\ L\ {\isacharampersand}\ G\ Tmin\ Tmax\ a\ L\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ order{\isacharunderscore}trans{\isacharcomma}\ rule\ R{\isacharunderscore }cond{\isacharunderscore}mono{\isacharparenright}\isanewline
\ \isacommand{using}\isamarkupfalse%
\ R{\isacharunderscore}therm{\isacharunderscore}dyn{\isacharunderscore}down{\isacharbrackleft}OF\ assms{\isacharbrackright}\ R{\isacharunderscore}therm{\isacharunderscore}dyn{\isacharunderscore}up{\isacharbrackleft}OF\ assms{\isacharbrackright}\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ intro{\isacharcolon} R{\isacharunderscore}cond{\isacharparenright}\isanewline
\end{isabellebody}

In particular for the dynamics we use (\ref{eq:r-evl}) to prove that each branch of the if-statement refines the specification (\isa{R{\isacharunderscore}therm{\isacharunderscore}dyn{\isacharunderscore}down/up}). Then we combine them by transitivity and (\ref{eq:r-cond}). Finally, we show that the loop of the composition of the specifications for the control and the dynamics refine $[I,I]$. We use this fact and transitivity to show $\mathsf{Thermostat}\leq [I,I]$.

\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}therm{\isacharunderscore}loop{\isacharcolon}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymge}\ \isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ Ref\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ I\ Tmin\ Tmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isasymrceil}{\isacharsemicolon}\isanewline
\ \ \ \ Ref\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ I\ Tmin\ Tmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isasymrceil}\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\isanewline
\ \ INV\ I\ Tmin\ Tmax{\isacharparenright}{\isachardoublequoteclose}\isanewline
\isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}intro\ R{\isacharunderscore}loop\ R{\isacharunderscore}seq{\isacharcomma}\ simp{\isacharunderscore}all{\isacharparenright}%
\isanewline
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}thermostat{\isacharunderscore}flow{\isacharcolon}\ \isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}a\ {\isachargreater}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ Tmin{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}Tmax\ {\isacharless}\ L{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymlceil}I\ Tmin\ Tmax{\isasymrceil}\ {\isasymge}\ \isanewline
\ \ {\isacharparenleft}LOOP\ {\isacharparenleft}\isanewline
\ \ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ \ {\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}{\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymle}\ Tmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ \ ELSE\ IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymge}\ Tmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ a\ {\isadigit{0}}\ {\isacharampersand}\ G\ Tmin\ Tmax\ a\ {\isadigit{0}}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}\ \isanewline
\ \ \ \ ELSE\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ a\ L\ {\isacharampersand}\ G\ Tmin\ Tmax\ a\ L\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}{\isacharparenright}{\isacharparenright}\isanewline
\ \ {\isacharparenright}\ INV\ I\ Tmin\ Tmax{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}intro\ order{\isacharunderscore}trans{\isacharbrackleft}OF\ {\isacharunderscore}\ R{\isacharunderscore}therm{\isacharunderscore}loop{\isacharbrackright}\ R{\isacharunderscore}loop{\isacharunderscore}mono\ \isanewline
\ \ \ \ \ \ R{\isacharunderscore}seq{\isacharunderscore}mono\ R{\isacharunderscore}therm{\isacharunderscore}ctrl\ R{\isacharunderscore}therm{\isacharunderscore}dyn{\isacharbrackleft}OF\ assms{\isacharbrackright}{\isacharparenright}\isanewline
\end{isabellebody}

The proof of \isa{R{\isacharunderscore}therm{\isacharunderscore}loop} applies law (\ref{eq:r-loop}), then (\ref{eq:r-seq}) and then a simplification. The final result \isa{R{\isacharunderscore}thermostat{\isacharunderscore}flow} is then a combination of the previous lemmas and the laws of our refinement calculus.\qed

\end{example}

\begin{example}[Water tank refinement via invariants]\label{ex:tank-rinv}
We use invariants to refine $\mathsf{Tank}$ from Example~\ref{ex:tank-inv}. Instead of doing it modularly, we do it in a single structured proof. We abbreviate uncritical parts of the proof with ellipses $\langle \dots\rangle$ and long expressions with schematic variables \isa{{\isacharparenleft}{\isacharquery}ctrl{\isacharcomma}{\isacharquery}dyn{\isacharcomma}{\isacharquery}ref{\isacharcomma}{\isacharquery}Ictrl{\isacharparenright}}. We follow the strategy of Example~\ref{ex:therm-rsol} with the exception that the dynamics are refined using the fact that $dI_k$ from Example~\ref{ex:tank-inv} is an invariant for $f_k$.
\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ tank{\isacharunderscore}diff{\isacharunderscore}inv{\isacharcolon}\isanewline
\ \ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}\ {\isasymLongrightarrow}\ diff{\isacharunderscore}invariant\ {\isacharparenleft}dI\ Hmin\ Hmax\ k{\isacharparenright}\ {\isacharparenleft}f\ k{\isacharparenright}\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isadigit{0}}\ Guard{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{proof}\rangle$\isanewline
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}tank{\isacharunderscore}inv{\isacharcolon}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ {\isasymtau}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}\ c\isactrlsub o{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}c\isactrlsub o\ {\isacharless}\ c\isactrlsub i{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymge}\isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ %
\isamarkupcmt{control%
}\isanewline
\ \ \ {\isacharparenleft}{\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}{\isacharparenleft}{\isadigit{3}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}{\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymle}\ Hmin\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{1}}{\isacharparenright}{\isacharparenright}\ ELSE\ \isanewline
\ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}\ {\isacharequal}\ {\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isasymge}\ Hmax\ {\isacharminus}\ {\isadigit{1}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{4}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}{\isadigit{0}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ %
\isamarkupcmt{dynamics%
}\isanewline
\ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{4}}{\isacharequal}{\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ {\isacharparenleft}c\isactrlsub i{\isacharminus}c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ G\ Hmax\ {\isacharparenleft}c\isactrlsub i{\isacharminus}c\isactrlsub o{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline 
\ \ \ \ \ DINV\ {\isacharparenleft}dI\ Hmin\ Hmax\ {\isacharparenleft}c\isactrlsub i{\isacharminus}c\isactrlsub o{\isacharparenright}{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ ELSE\ {\isacharparenleft}x{\isasymacute}{\isacharequal}\ f\ {\isacharparenleft}{\isacharminus}c\isactrlsub o{\isacharparenright}\ {\isacharampersand}\ G\ Hmin\ {\isacharparenleft}{\isacharminus}c\isactrlsub o{\isacharparenright}\ on\ {\isacharbraceleft}{\isadigit{0}}{\isachardot}{\isachardot}{\isasymtau}{\isacharbraceright}\ UNIV\ {\isacharat}\ {\isadigit{0}}\isanewline 
\ \ \ \ \ DINV\ {\isacharparenleft}dI\ Hmin\ Hmax\ {\isacharparenleft}{\isacharminus}c\isactrlsub o{\isacharparenright}{\isacharparenright}{\isacharparenright}{\isacharparenright}\ {\isacharparenright}\isanewline
\ \ INV\ I\ Hmin\ Hmax{\isacharparenright}{\isachardoublequoteclose}\ {\isacharparenleft}\isakeyword{is}\ {\isachardoublequoteopen}LOOP\ {\isacharparenleft}{\isacharquery}ctrl{\isacharsemicolon}{\isacharquery}dyn{\isacharparenright}\ INV\ {\isacharunderscore}\ {\isasymle}\ {\isacharquery}ref{\isachardoublequoteclose}{\isacharparenright}\isanewline
\isacommand{proof}\isamarkupfalse%
{\isacharminus}\isanewline
\ \ \isamarkupcmt{First we refine the control.}\isanewline
\ \ \isacommand{let}\isamarkupfalse%
\ {\isacharquery}Icntrl\ {\isacharequal}\ {\isachardoublequoteopen}{\isasymlambda}s{\isachardot}\ I\ Hmin\ Hmax\ s\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}\ {\isasymand}\ s{\isachardollar}{\isadigit{3}}\ {\isacharequal}\ s{\isachardollar}{\isadigit{1}}{\isachardoublequoteclose}\ $\langle \dots\rangle$\isanewline
\ \ \isacommand{hence}\isamarkupfalse%
\ ctrl{\isacharcolon}\ {\isachardoublequoteopen}{\isacharquery}ctrl\ {\isasymle}\ Ref\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}{\isachardoublequoteclose}\ $\langle \isa{proof}\rangle$\isanewline
\ \ \isamarkupcmt{Then we refine the dynamics.}\ $\langle \dots\rangle$\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ dyn{\isacharcolon}\ {\isachardoublequoteopen}{\isacharquery}dyn\ {\isasymle}\ Ref\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}{\isachardoublequoteclose}\ $\langle \isa{proof}\rangle$\isanewline
\ \ \isamarkupcmt{Finally we put everything together.}\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ pre{\isacharunderscore}pos{\isacharcolon}\ {\isachardoublequoteopen}{\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymle}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse\ simp\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ inv{\isacharunderscore}inv{\isacharcolon}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}{\isacharsemicolon}\ {\isacharparenleft}Ref\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}{\isacharparenright}\ {\isasymle}\ Ref\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse\ {\isacharparenleft}rule\ R{\isacharunderscore}comp{\isacharparenright}\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ loopref{\isacharcolon}\ {\isachardoublequoteopen}LOOP\ Ref\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}{\isacharsemicolon}\ {\isacharparenleft}Ref\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}{\isacharparenright}\ INV\ I\ Hmin\ Hmax\ {\isasymle}\ {\isacharquery}ref{\isachardoublequoteclose}\ $\langle \isa{proof}\rangle$\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ obs{\isacharcolon}\ {\isachardoublequoteopen}{\isacharquery}ctrl{\isacharsemicolon}{\isacharquery}dyn\ {\isasymle}\ Ref\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}{\isacharsemicolon}\ {\isacharparenleft}Ref\ {\isasymlceil}{\isacharquery}Icntrl{\isasymrceil}\ {\isasymlceil}I\ Hmin\ Hmax{\isasymrceil}{\isacharparenright}{\isachardoublequoteclose}\ $\langle \isa{proof}\rangle$\isanewline
\ \ \isacommand{show}\isamarkupfalse%
\ {\isachardoublequoteopen}LOOP\ {\isacharparenleft}{\isacharquery}ctrl{\isacharsemicolon}{\isacharquery}dyn{\isacharparenright}\ INV\ I\ Hmin\ Hmax\ {\isasymle}\ {\isacharquery}ref{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}rule\ order{\isacharunderscore}trans{\isacharbrackleft}OF\ {\isacharunderscore}\ loopref{\isacharbrackright}{\isacharcomma}\ rule\ R{\isacharunderscore}loop{\isacharunderscore}mono{\isacharbrackleft}OF\ obs{\isacharbrackright}{\isacharparenright}\isanewline
\isacommand{qed}\qed
\end{isabellebody}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Evolution Commands for Flows}\label{sec:from-flows}

Finally, we present variants of $\dH$ and $\dR$ that start directly
from flows $\flow:T\to S\to S$ instead of vector fields.  This avoids
checking the conditions of the Picard-Lindel\"of theorem and
simplifies verification proofs considerably.  Instead of
$x'=f\, \&\, G$, we now use the basic evolution command
$\mathbf{evol}\, \flow\, G$ in hybrid programs and define
\begin{equation*}
  (\mathbf{evol}\, \flow\, G) = \lambda s.\ \gamma^{\flow_s}_G\, s
\end{equation*}
with respect to the guarded orbit of $\flow_s$ along $T$ in $s$. It
then remains to derive a Hoare-style axiom and a refinement law
for such evolution commands. 
\begin{lemma}\label{P:hr-evlfl}
  Let $\flow:T\to S\to S$, where $S$ is a set and $T$ a
  preorder. Then, for $G,P,Q:S\to \bools$,
\begin{gather*}
\{\lambda s\in S.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)) \rightarrow P\,
(\flow_s\, t)\}\, \mathbf{evol}\, \flow\, G\, \{P\}. \label{eq:h-evlfl}\tag{h-evlfl}\\
\mathbf{evol}\, \flow\, G \le [\lambda s.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evlf}\tag{r-evlf}\\
(\mathbf{evol}\, \flow\, G) \cdot \left[Q,Q\right] \le [\lambda s. \forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t),Q],\label{eq:r-evlfl}\tag{r-evlfl}\\
\left[Q,\lambda s. \forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to Q\, (\flow_s\, t)\right]\cdot (\mathbf{evol}\, \flow\, G) \le [Q,Q].\label{eq:r-evlfr}\tag{r-evlfr}\\
\end{gather*}
\end{lemma}

\gin{do bouncing ball with ex euclidean space}

\begin{example}[Bouncing ball via Hoare logic]\label{ex:ball-hoare}
  Suppose a ball of mass $m$ falls down from height $h\geq 0$, with
  $x$ denoting its position, $v$ its velocity and $g$ its
  acceleration. Its kinematics is modelled by the function
  $\flow:\reals\to\reals^2\to\reals^2$ with
 \begin{equation*}
    \flow\, t\,
    \begin{pmatrix}
      s_x\\
      s_v
    \end{pmatrix}
=
\begin{pmatrix}
  s_x+s_v t-\frac{1}{2}gt^2\\
 s_v-g t
\end{pmatrix},
\end{equation*}
where we abbreviate
$s_x = s\, x$ and $s_v = s\, v$.  It bounces back
from the ground in an elastic collision, which is modelled using a
discrete control that checks whether $s_x=0$ and then flips the
velocity.  Guard $G=(\lambda s.\ s_x\geq 0)$ excludes any motion
below the ground. This is modelled by the hybrid
program~\cite{Platzer18}
\begin{align*}
	\mathsf{Cntrl} &= \IF {(\lambda\, s.\ s_x=0)} {v:=(\lambda\, s.\ - s_v)} \mathit{skip},\\
	\mathsf{Ball} &= ({\mathbf{evol}\, \flow\, G}\,  {;}\, \mathsf{Cntrl})^\ast.
\end{align*}
Its correctness specification is $\{P\}\, \mathsf{Ball}\, \{Q\}$ for $P= (\lambda s.\ s_x = h\land s_v = 0)$ and $Q  = (\lambda s.\ 0\leq s_x\leq h)$; its loop invariant
\begin{equation*}
      I = \left(\lambda s.\ 0\le s_x \land \frac{1}{2}s_v^2= g(h - s_x)\right).
\end{equation*}

We use Isabelle's \isa{{\isadigit{1}}{\isacharcomma} {\isadigit{2}}{\isacharcolon}{\isacharcolon}{\isadigit{2}}} for $x$ and $v$ respectively. The bouncing ball specification $\{P\}\, \mathsf{Ball}\, \{Q\}$ and its refinement version $\mathsf{Ball}\leq [P,Q]$ are then formalised as below. 
\begin{isabellebody}
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ bouncing{\isacharunderscore}ball{\isacharunderscore}dyn{\isacharcolon}\ {\isachardoublequoteopen}g\ {\isacharless}\ {\isadigit{0}}\ {\isasymLongrightarrow}\ h\ {\isasymge}\ {\isadigit{0}}\ {\isasymLongrightarrow}\isanewline
\ \ Hoare\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ h\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}{\isasymrceil}\isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}{\isacharparenleft}EVOL\ {\isacharparenleft}{\isasymphi}\ g{\isacharparenright}\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isasymge}\ {\isadigit{0}}{\isacharparenright}\ T{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isacharminus}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ h\ {\isacharplus}\ s{\isachardollar}{\isadigit{2}}\ {\isasymcdot}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}\isanewline
\ \ {\isacharparenright}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ h{\isasymrceil}{\isachardoublequoteclose}\isanewline
\ \isacommand{apply}\isamarkupfalse%
{\isacharparenleft}rule\ H{\isacharunderscore}loopI{\isacharcomma}\ rule\ H{\isacharunderscore}seq{\isacharbrackleft}\isakeyword{where}\ R{\isacharequal}{\isachardoublequoteopen}I\ g{\isachardoublequoteclose}{\isacharbrackright}{\isacharparenright}\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ bb{\isacharunderscore}real{\isacharunderscore}arith{\isacharparenright}\isanewline
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ R{\isacharunderscore}bouncing{\isacharunderscore}ball{\isacharunderscore }dyn{\isacharcolon}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}g\ {\isacharless}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}h\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Ref\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ h\ {\isasymand}\ s{\isachardollar}{\isadigit{2}}\ {\isacharequal}\ {\isadigit{0}}{\isasymrceil}\ {\isasymlceil}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ s{\isachardollar}{\isadigit{1}}\ {\isasymle}\ h{\isasymrceil}\ {\isasymge}\ \isanewline
\ \ {\isacharparenleft}LOOP\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}{\isacharparenleft}EVOL\ {\isacharparenleft}{\isasymphi}\ g{\isacharparenright}\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isasymge}\ {\isadigit{0}}{\isacharparenright}\ T{\isacharparenright}{\isacharsemicolon}\isanewline
\ \ \ \ \ \ \ {\isacharparenleft}IF\ {\isacharparenleft}{\isasymlambda}\ s{\isachardot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}\ THEN\ {\isacharparenleft}{\isadigit{2}}\ {\isacharcolon}{\isacharcolon}{\isacharequal}\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isacharminus}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}{\isacharparenright}\ ELSE\ skip{\isacharparenright}{\isacharparenright}\ \isanewline
\ \ \ \ INV\ {\isacharparenleft}{\isasymlambda}s{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ s{\isachardollar}{\isadigit{1}}\ {\isasymand}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ s{\isachardollar}{\isadigit{1}}\ {\isacharequal}\ {\isadigit{2}}\ {\isasymcdot}\ g\ {\isasymcdot}\ h\ {\isacharplus}\ s{\isachardollar}{\isadigit{2}}\ {\isasymcdot}\ s{\isachardollar}{\isadigit{2}}{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ $\langle \isa{\dots}\rangle$\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}rule\ R{\isacharunderscore}g{\isacharunderscore}evol{\isacharunderscore}rule{\isacharcomma}\ force\ simp{\isacharcolon}\ bb{\isacharunderscore}real{\isacharunderscore}arith{\isacharparenright} \isanewline
\end{isabellebody}

For the Hoare triple version of the bouncing ball, there is no need to supply any flow as it is already annotated in the specification. Therefore, as soon as the only sequential composition is addressed in the proof, the proof can be finished automatically by providing some arithmetical facts (\isa{bb{\isacharunderscore}real{\isacharunderscore}arith}). For the refinement version, the proof is longer for the control because we refine each of its atomic programs. However, the dynamics are quickly discharged with (\ref{eq:h-evlfl}) and the same arithmetical facts. \qed
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}\label{sec:conclusion}

We have contributed new methods and Isabelle components to an open
modular semantic framework for verifying hybrid systems that so far
focussed on predicate transformer methods~\cite{MuniveS19}; more
specifically the first standalone Hoare logic $\dH$ for hybrid
programs, the first Morgan-style refinement calculus $\dR$ for such
programs, more generic state spaces modelled by lenses, improved
Isabelle syntax for correctness specifications and hybrid programs,
and increased proof automation via Isabelle tactics.  As
previously~\cite{MuniveS19}, these components support three workflows
based on certifying solutions to Lipschitz-continuous vector fields,
reasoning with invariant sets for continuous vector fields, and
working directly with flows without certification.

Compared to the standard $\dL$ toolchain, $\dH$ and $\dR$ are
simple. They emphasise the natural mathematical style of reasoning
about dynamical systems, with minimal conceptual overhead relative to
standard Hoare logics and refinement calculi. The inference system of
$\dH$, in particular, remains invisible and is only used for automated
verification condition generation. The modular approach with algebras
and a shallow embedding has simplified the construction of these
verification components and made it incremental relative to extant
ones. Our framework is not only open to use any proof method and
mathematical approach supported by Isabelle, it should also allow
developers to add new methods, for instance based on discrete
dynamical systems, hybrid automata or duration
calculi~\cite{LiuLQZZZZ10} with minimal effort. It should be equally
straightforward to formalise $\dH$ and $\dR$ based on other Hoare
logics supported by Isabelle by plugging in our hybrid store models.

The relevance of Hoare logic and refinement calculi for hybrid systems
verification is further evidenced by the fact that such approaches are
not new: A hybrid Hoare logic has been proposed by Liu et
al.~\cite{LiuLQZZZZ10} for a duration calculus based on hybrid CSP and
been widely used since. Yet it is conceptually very different from
$\dH$ and $\dL$. A differential refinement logic based on $\dL$ has
been developed as part of Loos' PhD work~\cite{LoosP16}.  It is based
on a proof system with inference rules for reasoning about
inequalities between $\KAT$ expressions, which are interpreted in a
rather non-standard way as refinements between hybrid programs. It
differs substantially from the algebraic calculi developed by Back and
von Wright~\cite{BackW98}, Morgan~\cite{Morgan94} and others, and thus
from the predicate transformer algebras in~\cite{MuniveS19} and from
$\dR$.  The relative advantages and disadvantages of these approaches
remain to be explored.

The expressivity and complexity gap between Hoare logic and predicate
transformer semantics is particularly apparent within algebra. The
weakest liberal precondition operator---a standard predicate
transformer---cannot be expressed in $\KAT$~\cite{Struth18}.  The
equational theory of $\KAT$, which captures propositional Hoare logic,
is PSPACE complete, that of modal Kleene algebra, which yields
predicate transformers, is in EXPTIME~\cite{MollerS06}.  

Finally, while $\KAT$ and $\rKAT$ are convenient starting points for
building program construction and verification components for hybrid
programs, the simple and more general setting of Hoare
semigroups~\cite{Struth18} would support developing hybrid Hoare
logics for total program correctness---where balls may bounce
forever---or even for multirelational
semantics~\cite{FurusawaS16,FurusawaS15} as needed for differential
game logic~\cite{Platzer15}. This, however, is left for future work.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\bibliographystyle{abbrv}
\bibliography{hybrid-kat.bib}

\end{document}