\documentclass[envcountsame]{llncs}

\usepackage{isabelle,isabellesym}
\usepackage{graphicx}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{latexsym}
\usepackage{mathrsfs}
\usepackage{stmaryrd}
\usepackage{mathpartir} % inferrules
%\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{color}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[colorinlistoftodos]{todonotes}

\newcommand{\IF}[3]{\mathbf{if}\ #1\ \mathbf{then}\ #2\ \mathbf{else}\ #3}
\newcommand{\WHILE}[2]{\mathbf{while}\ #1\ \mathbf{do}\ #2}
\newcommand{\WHILEI}[3]{\mathbf{while}\ #1\ \mathbf{inv}\ #2\ \mathbf{do}\ #3}
\newcommand{\sskip}{\mathit{skip}}
\newcommand{\MKA}{\mathsf{MKA}}
\newcommand{\KAT}{\mathsf{KAT}}
\newcommand{\rKAT}{\mathsf{rKAT}}
\newcommand{\PDL}{\mathsf{PDL}}
\newcommand{\dL}{\mathsf{d}\mathcal{L}}
\newcommand{\flow}{\varphi}
\newcommand{\orbit}{\gamma^\varphi}
\newcommand{\lipschitz}{\ell}
\newcommand{\Pow}{\mathcal{P}}
\newcommand{\id}{\mathit{id}}
\newcommand{\Id}{\mathit{Id}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\bools}{\mathbb{B}}
\newcommand{\true}{\top}
\newcommand{\dLprog}{\Pi}
\newcommand{\ad}{\mathit{ad}}
\newcommand{\ar}{\mathit{ar}}
\newcommand{\wlp}{\mathit{wlp}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Rel}{\mathbf{Rel}}
\newcommand{\Sols}{\mathop{\mathsf{Sols}}}
\newcommand{\sta}{\mathsf{Sta}}
\newcommand{\rel}{\mathsf{Rel}}
\newcommand{\inv}{\mathsf{Inv}}

%\newcommand{\guards}[4]{(#1\circ #2)[#3,#4]}
\newcommand{\guards}[3]{#1\mathrel{\triangleright_#3} #2}
\newcommand{\gorbit}[1]{\gamma^#1_G}
\newcommand{\dinvar}[2]{( #1\hbox{ }\mathsf{invariant}\hbox{ }#2)}
%

\definecolor{scolor}{rgb}{1,0.5,0.5}
\definecolor{jcolor}{cmyk}{1,0,1,0}
\definecolor{gcolor}{cmyk}{1,0,0,0}


\newcommand\notein[3]{\todo[inline,linecolor=orange!80!black,backgroundcolor=#2!20]{#1: #3}%yellow!50 
}
\newcommand{\sfin}[1]{\notein{{\bf SF}}{scolor}{#1}}
\newcommand{\jin}[1]{\notein{{\bf JHM}}{jcolor}{#1}}
\newcommand{\gin}[1]{\notein{{\bf GS}}{gcolor}{#1}}

\urlstyle{rm}
\isabellestyle{it}

\begin{document}

\title{Hoare Logics and Refinement Calculi\\ for Hybrid Systems} \titlerunning{Hoare Logics and Refinement Calculi for Hybrid Systems}

\author{Simon Foster$^1$ \and Jonathan Juli\'an Huerta y Munive$^2$ \and Georg Struth$^2$} \authorrunning{Foster, Huerta y Munive and Struth}

\institute{University of York, UK \and University of Sheffield, UK}

\maketitle

\begin{abstract} 
  We present new Hoare logics and refinement calculi for the
  verification of hybrid programs in the style of differential dynamic
  logic. We use lenses for state spaces.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:introduction}

Research question: We already have a predicate transformer calculus,
for instance based on $\MKA$. We know that we can
specialise it to a Hoare logic and a Morgan-style refinement
calculus. But how can we derive standalone Isabelle components based
on $\KAT$. 

technical contributions:
\begin{itemize}
\item first Hoare logic for $\dL$-style hybrid programs,
\item first Morgan-style refinement calculus for these,
\item Isabell verification components for both:
  \begin{itemize}
  \item post-hoc verification and refinement by supplying flows for
    Lipschitz continuous vector fields,
\item post-hoc verification and refinement with invariants for continuous vector
  fields,
\item post-hoc verification and refinement components for flow based
  hybrid programs,
  \end{itemize}
\item lenses~\cite{FosterZW16},
\item specification statements with frames,
\item our store model plus executable euclidean spaces,
\item verification examples that demonstrate approach at work.
\end{itemize}

conceptual contributions: simple conceptual link between $\KAT$,
$\rKAT$, hybrid systems verification and standard verification
approaches beyond predicate transformers and $\dL$, now
domain-specific inference rules beyond assignment rules and refinement
laws for basic commands. 

Simplicity shows up in complexity and expressivity: equational theory
of $\KAT$ is PSPACE complete, that of $\MKA$, which underlies $\dL$, is
EXPTIME complete~\cite{MollerS06}. Weakest liberal preconditions,
which are the working horses of $\dL$, cannot be expressed in $\KAT$~\cite{Struth16}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kleene Algebra with Tests}\label{sec:kat} 

% A \emph{Kleene algebra} is a structure $(K,+,\cdot,0,1,^\ast)$, where
% $(S,+,\cdot,0,1)$ is a semiring with idempotent addition and the
% Kleene star $(-)^\ast:K\to K$ satisfies, for all
% $\alpha,\beta,\gamma\in K$, the axioms
% \begin{align*} 
% 1+\alpha\cdot\alpha^\ast &\le \alpha^\ast, \qquad
%   \gamma+\alpha\cdot
%                                           \beta\le \beta\rightarrow \alpha^\ast \cdot \gamma\le \beta,\\
%   1+\alpha^\ast\cdot\alpha &\le \alpha^\ast, \qquad \gamma+\beta\cdot
%                              \alpha\le \beta\rightarrow \gamma\cdot
%                              \alpha^\ast \le \beta.
% \end{align*}


A \emph{Kleene algebra with tests}~\cite{Kozen97} ($\KAT$) is a
structure $(K,B,+,\cdot,0,1,^\ast,\neg)$ where $(B,+,\cdot,0,1,\neg)$
is a boolean algebra with join $+$, meet $\cdot$, complementation
$\neg$, least element $0$ and greatest element $1$, $B\subseteq K$,
and $(K,+,\cdot,0,1,^\ast)$ is a Kleene algebra---a semiring with
idempotent addition equipped with a star operation that satisfies the
axioms $1+\alpha\cdot\alpha^\ast \le \alpha^\ast$ and
$\gamma+\alpha\cdot \beta\le \beta\rightarrow \alpha^\ast \cdot
\gamma\le \beta$,
as well as their opposities, with multiplication swapped.  The
ordering $\le$ on $K$ is defined by $x\le y\leftrightarrow x+y=y$, as
idempotent semirings are semilattices. We often write $\alpha\beta$
instead of $\alpha\cdot\beta$, and $p,q,r,\dots$ for elements of $B$.

Elements of $K$ represent programs; those of $B$ tests, assertions or
propositions.  The operation $\cdot$ models the sequential composition
of programs, $+$ their nondeterministic choice, $(-)^\ast$ their finite
unbounded iteration. Program $0$ aborts and $1$ skips.  Tests are
meant to hold in some states of a program and fail in others;
$p\alpha$ ($\alpha p$) restricts the execution of program $\alpha$ in
its input (output) to those states where test $p$ holds. The ordering
$\le$ is the opposite of the refinement ordering on programs (see Section~\ref{sec:refine}).

Binary relations of type $\Pow\, (S\times S)$ form
$\KAT$s~\cite{Kozen97} when $\cdot$ is interpreted as relational
composition, $+$ as relational union, $(-)^\ast$ as
reflexive-transitive closure and the elements of $B$ as
subidentities---relations below the relational unit. This grounds
$\KAT$ within standard relational imperative program semantics. Yet we
prefer the isomorphic representation as \emph{state transformers} of
type $S\to \Pow\, S$.  Composition $\cdot$ is then interpreted as
Kleisli composition
\begin{equation*} 
(f\circ_K g)\, x = \bigcup\{g\, y\mid y \in f\ x \}, 
\end{equation*} 
$0$ as $\lambda x.\ 0$ and $1$ as $\eta_S = \{-\}$.  Stars
$f^{\ast}  = \bigcup_{i\in\mathbb{N}} f^i$ are defined with
  respect to Kleisli composition with $f^{0} = \eta_S$ and
  $f^{n+1} = f \circ_K f^{n}$. The boolean algebra of tests has
  carrier set $B_S=\{f:S\to \Pow\, S \mid f\le \eta_S\}$, where the
  order on functions has been extended pointwise,  and complementation
  is given by
  \begin{equation*} 
    \overline{f}\, x =
  \begin{cases}
    \eta_S\, x, & \text{ if } f\, x = \emptyset,\\
\emptyset, & \text{ otherwise}.
  \end{cases}
\end{equation*}
We freely identify predicates, sets and state 
transformers below $\eta_S$, which are isomorphic:
$P\cong \{s\mid P\, s\}\cong \lambda s.\ \{x\mid x=s \land P\, s\}$.

\begin{proposition}\label{P:kleisli-ka}
$\sta\, S = ((\Pow\, S)^S,B_S,\cup,\circ_K,\lambda x.\
  \emptyset, \eta_S,(-)^{\ast},\overline{(-)})$
  forms a $\KAT$, the \emph{full state transformer $\KAT$} over the
  set $S$.
\end{proposition}
A \emph{state transformer $\KAT$} over $S$ is any subalgebra of
$\sta\, S$. 

We have already formalised $\KAT$ as type classes in
Isabelle~\cite{afp:kat}.  As these allow only one type parameter, we
are using a non-standard approach that expands a Kleene algebra $K$ by
an \emph{antitest} function $n:K\to K$ from which a \emph{test}
function $t:K\to K$ is defined as $t=n^2$. Then
$K_t = \{\alpha \mid t\, \alpha = \alpha\}$ forms a boolean algebra in
which $n$ acts as test complementation. It can be used in place of the
boolean algebra $B$.  A formalisation of the relational model of
$\KAT$ can be found in~\cite{afp:kat}; that of the state transformer
model is a contribution to this article.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Propositional Hoare Logic and Invariants}\label{sec:hl-invariants}

It is well known that $\KAT$ provides an algebraic semantics for while
programs,
\begin{align*}
  \IF{p}{\alpha}{\beta} = p\cdot \alpha + \bar p \cdot
  \beta\qquad\text{ and }\qquad
\WHILE{p}{\alpha} = (p\cdot \alpha)^\ast \cdot \bar p.
\end{align*}
It captures validity of Hoare triples in
a partial correctness semantics as
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow p\alpha\neg q = 0,
\end{equation*}
or equivalently by $p\alpha\le \alpha q$ or $p\alpha = p\alpha q$. It
also allows deriving the rules of \emph{propositional Hoare
  logic}~\cite{Kozen00}---disregarding assignments---which we use for
verification condition generation:
\begin{align}
  &\{p\}\, \sskip\, \{p\}, \label{eq:h-skip}\tag{h-skip}\\
  p\le p' \land \{p'\}\, \alpha\, \{q'\} \land q'\le q\ \rightarrow\ &
                                                                       \{p\}\,
                                                                       \alpha\,
                                                                       \{q\},\label{eq:h-cons}\tag{h-cons}\\
  \{p\}\, \alpha\, \{r\} \land \{r\}\, \beta\, \{q\}\ \rightarrow\
  &\{p\}\, \alpha\beta\, \{q\},\label{eq:h-seq}\tag{h-seq}\\
  \{tp\}\, \alpha\, \{q\}\land \{\neg tp\}\, \beta\, \{q\}\
  \rightarrow\ & \{p\}\, \IF{t}{\alpha}{\beta}\, \{q\},\label{eq:h-cond}\tag{h-cond}\\
  \{tp\}\, \alpha\, \{p\}\ \rightarrow\ & \{p\}\, \WHILE{t}{\alpha}\, \{\neg tp\}.\label{eq:h-while}\tag{h-while}
\end{align}
Rules for commands with invariant assertions $\alpha\ \mathbf{inv}\ i$
are derivable, too (operationally,
$\alpha\, \mathbf{inv}\, i = \alpha$).  An \emph{invariant} for
$\alpha\in K$ is an $i\in B$ satisfying $\{i\}\, \alpha\, \{i\}$.
Then, with $\mathbf{loop}\, \alpha$ as syntactic sugar for
$\alpha^\ast$, we obtain
\begin{align}
  p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\
  &\{p\}\, \alpha\, \{q\},\label{eq:h-inv}\tag{h-inv}\\
  p \le i \wedge \{it\}\, \alpha\, \{i\} \wedge \neg t i\le q\
  \rightarrow \ & \{p\}\, \WHILEI{t}{i}{\alpha}\,  \{q\},\label{eq:h-while-inv}\tag{h-while-inv}\\
   p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\ &
                                                                   \{p\}\, \mathbf{loop}\, \alpha\,
    \mathbf{inv}\, i\, \{q\}. \label{eq:h-loop-inv}\tag{h-loop-inv}
\end{align}
We use (\ref{eq:h-inv})---an instance of (\ref{eq:h-cons})---to reason
about invariants for continuous evolutions of hybrid systems in
Section~\ref{sec:hoare-inv}, \ref{sec:refine} and
\ref{sec:from-flows}. Rule (\ref{eq:h-while-inv}) is standard for
reasoning with invariants for while loops; (\ref{eq:h-loop-inv}) is
specific to loops of hybrid programs (see
Section~\ref{sec:sta-hybrid}).

The rules for propositional Hoare logic in Isabelle have been
derived for
$\KAT$ in~\cite{afp:kat,afp:vericomp}. Basic Isabelle infrastructure for
reasoning with general invariants has been developed for this
article. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{State Transformer Semantics of Hybrid
  Programs}\label{sec:sta-hybrid}

\gin{Simon: add some paras on lenses.}

Hybrid programs of differential dynamic logic ($\dL$)~\cite{Platzer18}
are defined by the syntax
\begin{equation*}
\mathcal{C}\ ::= \ x:=e \mid x' = f \, \&\, G \mid ?P\mid \mathcal{C};\mathcal{C}\mid \mathcal{C}+\mathcal{C}\mid \mathcal{C}^*
\end{equation*}
that adds \emph{evolution commands} $x' = f \, \&\, G$ to the language
of $\KAT$---function $?(-)$ embeds tests explicitly into programs.
Evolution commands introduce a time independent vector field $f$ for
an autonomous system of ordinary differential equations
(ODEs)~\cite{Teschl12} and a guard $G$, a predicate modelling
boundary conditions or similar restrictions of temporal
evolutions. % Guards are also known as \emph{evolution domain
  % restrictions}~\cite{DoyenFPP18}.

Formally, vector fields are functions of type $S\to S$ on some open set
$S\subseteq \reals^n$ and $n\in\mathbb{N}$---the state space of
the hybrid program. We assume that program variables range from $0$ to
$n-1$, or pick them from any set $V$ isomorphic to the finite ordinal
$n$. Program states in $S$ can thus be identified with hybrid program
stores modelled as functions from variables in $V$ to values in
$\reals$, as usual.

Geometrically, vector field $f$ assigns a vector to any point of the
state space
$S$. A solution to the \emph{initial value problem} (IVP) for the pair
$(f,s)$ and initial value $(0,s)\in T\times S$, where $T$ is an open
interval in $\reals$ containing $0$, is then a function $X:T\to S$
that satisfies $X'\, t = f\, (X\, t)$---an autonomous system of ODEs
in vector form---and $X\, 0 = s$. Solution
$X$ is thus a curve in $S$ through $s$, parametrised in $T$ and
tangential to $f$ at any point in $S$; it is called \emph{trajectory}
or \emph{integral curve} of $f$ at $s$ whenever it is uniquely
defined ~\cite{Teschl12}.

For IVP $(f,s)$ with continuous vector field $f:S\to S$ and initial
state $s\in S$ we define the set of solutions on
$T$ as
\begin{equation*}
\Sols f\, T\, s = \{X \mid \forall t\in T.\  X'\, t = f\, (X\, t)\land X\, 0 = s\}.
\end{equation*}
Each solution $X$ is then continuously differentiable and thus
$f\circ X$ integrable in $T$.  For $X\in \Sols\, f\, T\, s$ and
$G:S\to\bools$, we further define the $G$-\emph{guarded orbit} of $X$
along $T$ in $s$~\cite{MuniveS19} with the help of the state transformer
$\gamma^X_G:S\to \Pow\, S$ as 
\begin{equation*}
\gamma^X_{G}\, s= \{X\, t\mid t\in T\land \forall \tau\in
{\downarrow}t.\ G\, (X\, \tau)\},
\end{equation*}
where ${\downarrow}t = \{t'\in T\mid t'\le t\}$, and the
$G$-\emph{guarded orbital} of $f$ along $T$ in $s$~\cite{MuniveS19}
via the state transformer $\gamma^f_G:S\to \Pow\, S$ as
\begin{equation*}
  \gamma^f_G\ s = \bigcup\{\gamma^X_G\, s\mid X\in \Sols\, f\, T\, s\}.
\end{equation*}
In applications, ${\downarrow}t$ is typically an interval
$[0,t]\subseteq T$.  Expanding definitions,
\begin{equation*}
\gamma^f_G\, s = \{X\, t \mid X\in \Sols\, f\, T\, s \land t\in T
\land \forall \tau\in{\downarrow}t.\ G\, (X\, \tau)\}.
\end{equation*}
If $\top$ either denotes the predicate that holds of all states in $S$
or the set $S$ itself, we write $\gamma^f$ instead of
$\gamma^f_\top$.

We define the semantics of the evolution command
$x'= f\, \&\, G$~\cite{MuniveS19} for any continuous $f:S\to S$ and
$G:S\to \bools$ as
\begin{equation}
{(x'= f\, \&\, G)} = \gamma^f_G.\label{eq:st-evl}\tag{st-evl}
\end{equation}

Defining the state transformer semantics of assignments is
straightforward~\cite{MuniveS19}. First we define a state update
function $f_a:V\to (S \to E) \to S\to S$ as
\begin{equation*}
f_a\, x\, e\, s = s[x\mapsto e\, s],
\end{equation*}
where $f[a\mapsto b]$ updates $f:A\to B$ by associating $a\in A$ with
$b$ and every $y\neq a$ with $f\, y$.  The ``expression''
${e:S\to \reals}$ is thus evaluated in state $s$ to $e\, s$.  Then we
lift $f_a\, x\, e:S\to S$ to state transformer
$x:= e:S \to \Pow\, S$ using $\eta_S$:
\begin{equation}
  (x:= e) = \lambda s.\ \{f_a\, x\, e\, s\}.\label{eq:st-assgn}\tag{st-assgn}
\end{equation}

The development in this section has been formalised with
Isabelle~\cite{afp:hybrid}, both for a state transformer and a
relational semantics. An instance of the latter for particular vector
fields with unique solutions forms the standard semantics of
differential dynamic logic. Due to the connection to orbits or
orbitals, the state transformer semantics is arguably conceptually
simpler and more elegant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Flow-Based Hoare Logic for Hybrid
  Programs}\label{sec:hoare-flow}

The assignment axiom of Hoare logic need not be explained. Our
semantics yilds a variant with update functions instead
of substitutions:
\begin{equation}
\{\lambda s.\ P\, s[x\mapsto e\, s]\}\,  x:=e\, \{P\}. \label{eq:h-assgn}\tag{h-assgn}
\end{equation}
Hence it remains to derive a rule for evolution commands.  We restrict
our attention to Lipschitz-continuous vector fields for which unique
solutions to IVPs are guaranteed by Picard-Lindel\"of's
theorem~\cite{Teschl12}.  These are \emph{(local)\ flows}
$\flow:T\to S\to S$ and $X=\flow_s=\lambda t.\ \flow\, t\, s$ is the
trajectory at $s$. Guarded orbitals $\gamma^f_G$  then specialise to
\emph{guarded orbits}
\begin{equation*}
  \gamma^f_{G,U} = \{\flow_s\, t\mid t\in U\land \forall\tau \in
  {\downarrow}t.\ G\, (\flow_s\, t)\},
\end{equation*}
where $U\subseteq T$ is a time domain of interest, typically an
interval $[0,t]$ for some $t\in T$~\cite{MuniveS19}.  Accordingly,
(\ref{eq:st-evl}) becomes
\begin{equation}
  (x' = f\, \&\, G)= \gamma^f_{G,U}.\label{eq:st-evl-flow}\tag{st-evl-flow}
\end{equation}
The following Hoare-style rule for evolution commands is then
derivable.
\begin{lemma}\label{P:h-evl-lemma}
\gin{add the right conditions}
\begin{equation}
\{\lambda s\in S.\forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)) \rightarrow P\,
(\flow_s\, t)\}\, x' = f\, \&\, G\, \{P\}. \label{eq:h-evl}\tag{h-evl}
\end{equation}
\end{lemma}

This finishes the derivation of rules for a Hoare logic for hybrid
programs---to our knowledge, the first Hoare logic of this kind. As
usual, there is one rule per programming construct, so that their
recursive application generates proof obligations that are entirely
about data-level relationships---the discrete and continuous evolution
of the hybrid program store.

The Hoare-style rule~(\ref{eq:h-evl}) supports the following procedure
for reasoning with an evolution command $x' = f\, \&\, G$ on a set $U$
in this calculus:
\begin{enumerate}
\item Check that vector field $f$ satisfies the conditions for
  Picard-Lindel\"of's theorem ($f$ is Lipschitz continuous and
  $S\subseteq\reals^n$ is open).
\item Supply a (local) flow $\flow$ for $f$ with open interval of
  existence $T$ around $0$.
\item Check that $\flow_s$ solves the IVP $(f,s)$ for each $s\in S$;
  that is, $\flow_s'\, t = f\, (\flow_s\, t)$, $\flow_s\, 0 = s$, and
  $U\subseteq T$.
\item If successful, apply rule~(\ref{eq:h-evl}).
\end{enumerate}

\gin{add example: thermostat (done)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Invariant-Based Hoare Logic for Hybrid Programs}\label{sec:hoare-inv}

Alternatively, our Hoare logic supports reasoning with invariants for
evolution commands instead of supplying flows to the
rule~(\ref{eq:h-evl}), similar to~\cite{MuniveS19}. Our invariants
generalise the \emph{differential invariants} of
$\dL$~\cite{Platzer18} and the \emph{invariant sets} of dynamical
systems  and (semi)group theory~\cite{Teschl12} .

A predicate $I:S\to\bools$ is an \emph{invariant} of the continuous
vector field $f:S\to S$ and guard $G:S\to\bools$ \emph{along}
$T\subseteq \reals$ if
\begin{equation*}
\bigcup \Pow\, \gamma^f_G\, I\subseteq  I.
\end{equation*}
The operation $\bigcup\circ\Pow$ is the Kleisli extension $^\dagger$
in the powerset monad. Hence we could simply write
$(\gamma^f_gG)^\dagger\, I \subseteq I$. The definition of invariance
unfolds to
\begin{equation*}
  \forall s.\ I\, s \to (\forall X\in\Sols f\, T\, s.\forall t\in T.\ (\forall \tau\in {\downarrow}t.\ G\, (X\, \tau)) \to I\, (X\, t)).
\end{equation*}
For $G=\top$ we call $I$ an \emph{invariant} of $f$ along $T$.
Intuitively, invariants can be seen as sets of orbits.

Invariants for evolution commands are coherent with those in Section~\ref{sec:hl-invariants}.
\begin{proposition}\label{P:inv-prop}
  Let $f:S\to S$ be continuous, $G:S\to\bools$ and
  $T\subseteq \reals$. Then $I$ is an invariant for $f$ and $G$ \emph{along} $T$ if and only if
$ \{I\}\, x' = f\, \&\, G\, \{I\}$.
\end{proposition}
Hence we can use an instance of (\ref{eq:h-inv}) for verification condition generation:
\begin{align}
  P\le I \land \{I\}\, x' = f\, \&\, G\, \{I\}\land (I\cdot G)\le Q\ \rightarrow\
  &\{P\}\, x' = f\, \&\, G\, \{Q\}.\label{eq:h-invg}\tag{h-invg}
\end{align}
It remains to check invariance in the antecedent of this rule. The
following lemma leads to a procedure.

\begin{lemma}\label{P:invrules}
  Let $f:S\to S$ be a continuous vector field, $\mu,\nu:S\to\reals$
  differentiable and $T\subseteq \reals$. 
\begin{enumerate}
\item If $(\mu\circ X)' =(\nu\circ X)'$ for all
  $X\in \Sols f\, T\, s$, then $\{\mu=\nu\}\, x' = f\, \&\, G\, \{\mu=\nu\}$, 
\item if $(\mu\circ X)'\, t\leq(\nu\circ X)'\, t$ when $t> 0$, and $(\mu\circ X)'\, t\geq(\nu\circ X)'\, t$ when $t< 0$, for all $X\in \Sols f\, T\, s$,
  then $\{\mu <\nu\}\, x' = f\, \&\, G\, \{\mu <\nu\}$
\item $\mu\neq \nu$ if and only if $\mu < \nu$ or $\nu < \mu$,
\item $\mu \not\le \nu$ if and only if $\nu < \mu$,
\jin{get Hoare triple version in Isabelle}
\item if $\{I_i\}\, x' = f\, \&\, G\, \{I_i\}$for $i\in\{1,2\}$, then $\{I_1\land I_2\}\, x' = f\, \&\, G\, \{I_1\land I_2\}$ and $\{I_1\lor I_2\}\, x' = f\, \&\, G\, \{I_1\lor I_2\}$.
%\item if $I_1$ and $I_2$ are differential invariants for $f$ along $T$, then so are $\lambda s.\ I_1\, s \land I_2\, s$ and $\lambda s.\ I_1\, s \lor I_2\, s$.
\end{enumerate}
\end{lemma}

Condition $(1)$ follows from the well known fact that two continuously
differentiable functions are equal if they intersect at some point and their
derivatives are equal. Therefore, rule (\ref{eq:h-invg}),
Proposition~\ref{P:inv-prop} and Lemma~\ref{P:invrules} yield the following
procedure for verifying a triple $\{P\}\, x' = f\, \&\, G\, \{Q\}$
using an invariant.
\begin{enumerate}
\item Check whether a candidate predicate $I$ is am invariant for $f$
  along $T$:
	\begin{enumerate}
	\item transform $I$ into negation normal form;
	\item if $I$ is complex, reduce it with Lemma~\ref{P:invrules} (3), (4) and (5);
	\item if $I$ is atomic, apply Lemma~\ref{P:invrules} (1) and (2);
	\end{enumerate}
(if successful,  $\{I\}\, x' = f\, \&\, G\, \{I\}$ holds by Proposition~\ref{P:inv-prop}),
\item if successful, prove $P\le I$ and $(I\cdot G)\le Q$ to apply rule (\ref{eq:h-invg}).
\end{enumerate}

\gin{add example: water tank (done)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Refinement Calculi for Hybrid Programs}\label{sec:refine}

A \emph{refinement Kleene algebra with tests}
($\rKAT$)~\cite{ArmstrongGS16}  is a $\KAT$
$(K,B)$ expanded by an operation $[-,-]:B\times B\to K$ that
satisfies, for all $\alpha \in K$ and $p,q\in B$, 
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow \alpha\le [p,q].
\end{equation*}
The element $[p,q]$ of $K$ is called \emph{specification
  statement}~\cite{Morgan94}. It satisfies 
\begin{equation*}
  \{p\}\, [p,q]\, \{q\}\qquad \text{ and }\qquad \{p\}\, \alpha\, \{q\} \rightarrow \alpha\le [p,q],
\end{equation*}
which makes $[p,q]$ the greatest element of $K$ that satisfies the Hoare
triple with precondition $p$ and postcondition $q$.  Indeed, in
$\sta\, S$ and for $S\subseteq \reals^n$,
\begin{equation*}
  [P,Q] = \bigcup \left\{f:S\to \Pow\, S \mid \{P\}\, f\, \{Q\}\right\}.
\end{equation*}

The classical laws~\cite{Morgan94} of a \emph{propositional
  refinement calculus} are then derivable in $\rKAT$~\cite{ArmstrongGS16}.
\begin{align}
  1 &\le [p,p],\label{eq:r-skip}\tag{r-skip}\\
[p',q'] &\le [p,q],\qquad \text{ if } p\le p'\text{ and } q'\le q,\label{eq:r-cons}\tag{r-cons}\\
\alpha & \le [0,1],\\
[1,0] &\le \alpha,\\
[p,r]\cdot [r,q] &\le [p,q],\label{eq:r-seq}\tag{r-seq}\\
\IF{t}{[tp,q]}{[\neg tp,q]} &\le [p,q],\label{eq:r-cond}\tag{r-cond}\\
 \WHILE{t}{[tp,p]} &\le [p,\neg tp]. \label{eq:r-while}\tag{r-while}
\end{align}

For invariants and loops, we obtain the additional refinement laws
\begin{align}
  [i,i] &\le [p,q],\qquad \text{ if } p\le i \le q,\label{eq:r-inv}\tag{r-inv}\\
\mathbf{loop} [i,i] &\le [i,i]. \label{eq:r-loop}\tag{r-loop}
\end{align}

In $\sta\, S$, moreover, the following assignments laws are
derivable~\cite{ArmstrongGS16}.
\begin{align}
 (x := e)  &\le  [\lambda s.\ P\, s[x\mapsto e\, s],P],\label{eq:r-assgn}\tag{r-assgn}\\
(x:= e) \cdot [\lambda s.\ P\, s[x\mapsto e\, s],P] &\le [P,P],\label{eq:r-assgn}\tag{r-assgnl}\\
[P,\lambda s.\ P\, s[x\mapsto e\, s]]\cdot (x:=e) &\le [P,P]. \label{eq:r-assgn}\tag{r-assgnf}
\end{align}
The second and third law are known as \emph{leading} and \emph{following}
law. They introduce an assignment before and after a block of code. 

Finally, we obtain the following refinement laws for evolution
commands.
\begin{lemma}\label{P:r-evl-lemma}
\gin{add conditions}
\begin{equation}
x' = f\, \&\, G \le [\lambda s.\forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to P\, (\flow_s\, t),P]. \label{eq:r-evl}\tag{r-evl}
\end{equation}
\end{lemma}

\gin{we also need to derive leading/following laws
  for evolution statements.}

These laws suffice for constructing hybrid programs from initial
specification statements by step-wise refinement incrementally and
compositionally. To our knowledge this is the first refinement
calculus for hybrid programs of this kind.  A more powerful variant
based on predicate transformers \`a la Back and von
Wright~\cite{BackW98} has been developed in~\cite{MuniveS19}, but
applications remain to be explored.  A previous approach to refinement
for hybrid programs in $\dL$~\cite{LoosP16} seems quite different to
the two standard calculi mentioned and much more intricate than the
approach presented.

\gin{do two examples; one for flows (thermostat, stepwise, done), one for
  invariants (water tank, in one go,  with ex euclidean space, tbd).}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Starting from Flows}\label{sec:from-flows}

Finally, we present an approach that starts directly from
flows $\flow:T\to S\to S$ instead of vector fields.  This avoids
checking the conditions of the Picard-Lindel\"of theorem, which
simplifies verification proofs considerably.  Instead of $x'=f\, \&\,
G$, we now use the basic evolution command $\mathbf{evol}\, \flow\, G$
in hybrid programs and define
\begin{equation*}
  (\mathbf{evol}\, \flow\, G) = \lambda s.\ \gamma^{\flow_s}_G\, s
\end{equation*}
with respect to the guarded orbit of $\flow_s$ along $T$ in $s$. We
can then derive a Hoare-style axiom and refinement law
for such evolution commands as in previously.
\begin{lemma}\label{P:hr-evlfl}
\gin{add conditions}
\begin{gather}
\{\lambda s\in S.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)) \rightarrow P\,
(\flow_s\, t)\}\, \mathbf{evol}\, \flow\, G\, \{P\}. \label{eq:h-evlfl}\tag{h-evlfl}\\
\mathbf{evol}\, \flow\, G \le [\lambda s.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to P\, (\flow_s\, t),P]. \label{eq:r-evlfl}\tag{r-evlfl}
\end{gather}
\end{lemma}

\gin{do following and leading assignments laws and bouncing ball
  examples for verification (done) and refinement (step wise, with ex euclidean
  space, tbd).}

\begin{example}[Bouncing ball via Hoare logic]\label{ex:ball-hoare}
  Suppose a ball of mass $m$ falls down from height $h\geq 0$, with
  $x$ denoting its position, $v$ its velocity and $g$ its
  acceleration. Its kinematics is modelled by the vector field
  $f:\reals^V\to\reals^V$ with
 \begin{equation*}
    f\,
    \begin{pmatrix}
      s_x\\
      s_v
    \end{pmatrix}
=
\begin{pmatrix}
  s_v\\
-g
\end{pmatrix},
\end{equation*}
where we abbreviate
$s_x = s\, x$ and $s_v = s\, v$.  It bounces back
from the ground in an elastic collision, which is modelled using a
discrete control that checks whether $s_x=0$ and then flips the
velocity.  Guard $G=(\lambda s.\ s_x\geq 0)$ excludes any motion
below the ground. This is modelled by the hybrid
program~\cite{Platzer18}
\begin{align*}
	\mathsf{Cntrl} &= \IF {(\lambda\, s.\ s_x=0)} {v:=(\lambda\, s.\ - s_v)} \mathit{skip},\\
	\mathsf{Ball} &= ({x'=f\, \&\, G}\,  {;}\, \mathsf{Cntrl})^\ast.
\end{align*}
Its correctness specification is
\begin{equation*}
\{P\}\, \mathsf{Ball}\, \{Q\}
\end{equation*}
for $P= (\lambda s.\ s_x = h\land s_v = 0)$ and $Q  = (\lambda s.\
0\leq s_x\leq h)$; its loop invariant
\begin{equation*}
      I = \left(\lambda s.\ 0\le s_x \land \frac{1}{2}s_v^2= g(h - s_x)\right).
\end{equation*}
\gin{put isabelle stuff here.}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}\label{sec:conclusion}

Development generalises further to Hoare semigroups and refinement
semigroups~\cite{Struth18}. This is left for future work.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\bibliographystyle{abbrv}
\bibliography{hybrid-kat.bib}

\end{document}