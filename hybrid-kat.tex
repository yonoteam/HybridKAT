\documentclass[envcountsame]{llncs}

\usepackage{isabelle,isabellesym}
\usepackage{graphicx}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{latexsym}
\usepackage{mathrsfs}
\usepackage{stmaryrd}
\usepackage{mathpartir} % inferrules
%\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{color}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[colorinlistoftodos]{todonotes}

\newcommand{\IF}[3]{\mathbf{if}\ #1\ \mathbf{then}\ #2\ \mathbf{else}\ #3}
\newcommand{\WHILE}[2]{\mathbf{while}\ #1\ \mathbf{do}\ #2}
\newcommand{\WHILEI}[3]{\mathbf{while}\ #1\ \mathbf{inv}\ #2\ \mathbf{do}\ #3}
\newcommand{\sskip}{\mathit{skip}}
\newcommand{\MKA}{\mathsf{MKA}}
\newcommand{\KAT}{\mathsf{KAT}}
\newcommand{\rKAT}{\mathsf{rKAT}}
\newcommand{\PDL}{\mathsf{PDL}}
\newcommand{\dL}{\mathsf{d}\mathcal{L}}
\newcommand{\dH}{\mathsf{d}\mathcal{H}}
\newcommand{\dR}{\mathsf{d}\mathcal{R}}
\newcommand{\flow}{\varphi}
\newcommand{\orbit}{\gamma^\varphi}
\newcommand{\lipschitz}{\ell}
\newcommand{\Pow}{\mathcal{P}}
\newcommand{\id}{\mathit{id}}
\newcommand{\Id}{\mathit{Id}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\bools}{\mathbb{B}}
\newcommand{\true}{\top}
\newcommand{\dLprog}{\Pi}
\newcommand{\ad}{\mathit{ad}}
\newcommand{\ar}{\mathit{ar}}
\newcommand{\wlp}{\mathit{wlp}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Rel}{\mathbf{Rel}}
\newcommand{\Sols}{\mathop{\mathsf{Sols}}}
\newcommand{\sta}{\mathsf{Sta}}
\newcommand{\rel}{\mathsf{Rel}}
\newcommand{\inv}{\mathsf{Inv}}

%\newcommand{\guards}[4]{(#1\circ #2)[#3,#4]}
\newcommand{\guards}[3]{#1\mathrel{\triangleright_#3} #2}
\newcommand{\gorbit}[1]{\gamma^#1_G}
\newcommand{\dinvar}[2]{( #1\hbox{ }\mathsf{invariant}\hbox{ }#2)}
%

\definecolor{scolor}{rgb}{1,0.5,0.5}
\definecolor{jcolor}{cmyk}{1,0,1,0}
\definecolor{gcolor}{cmyk}{1,0,0,0}


\newcommand\notein[3]{\todo[inline,linecolor=orange!80!black,backgroundcolor=#2!20]{#1: #3}%yellow!50 
}
\newcommand{\sfin}[1]{\notein{{\bf SF}}{scolor}{#1}}
\newcommand{\jin}[1]{\notein{{\bf JHM}}{jcolor}{#1}}
\newcommand{\gin}[1]{\notein{{\bf GS}}{gcolor}{#1}}

\urlstyle{rm}
\isabellestyle{it}

\begin{document}

\title{Differential Hoare Logics and Refinement Calculi\\ for Hybrid Systems with Isabelle/HOL}
\titlerunning{Hoare Logics and Refinement Calculi for Hybrid
  Systems}

\author{Simon Foster$^1$ \and Jonathan Juli\'an Huerta y Munive$^2$ \and Georg Struth$^2$} \authorrunning{Foster, Huerta y Munive and Struth}

\institute{University of York, UK \and University of Sheffield, UK}

\maketitle

\begin{abstract} 
  We present simple new Hoare logics and refinement calculi for hybrid
  programs in the style of differential dynamic logic. (Refinement)
  Kleene algebra with tests is used for reasoning about the program
  structure and generating verification conditions at this level.
  Lenses capture hybrid program stores in a generic algebraic way. The
  approach has been formalised with the Isabelle/HOL proof
  assistant. A number of examples explains the workflow with the
  resulting verification components.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:introduction}

Differential dynamic logic ($\dL$) is a prominent deductive method for
verifying hybrid systems~\cite{Platzer18}. It extends dynamic logic
with domain-specific inference rules for reasoning about the discrete
control and continuous dynamics that are characteristic for such
systems. Continuous evolutions are modelled in $\dL$'s evolution
commands within a hybrid program syntax. These declare a vector field
and a guard, which is meant to hold along the evolution.  Reasoning
with evolution commands in $\dL$ requires either explicit solutions to
differential equations represented by the vector field, or else
invariant sets~\cite{Teschl12} that describe evolutions
implicitly. $\dL$-inspired verification components have already been
formalised in the Isabelle proof assistant~\cite{MuniveS19}. Yet the
shallow embedding used has shifted the focus from the original
proof-theoretic approach to a semantic one, and ultimately to
predicate transformer algebras supporting a quite different workflow.

Dynamic logics and predicate transformers are powerful tools. They
support reasoning about program equivalences and transformations
beyond what standard program verification requires~\cite{BackW98}. For
the latter, much simpler Hoare logics generate precisely the
verification conditions needed.  Asking about the feasibility of a
\emph{differential Hoare logic} ($\dH$) is therefore natural and
interesting.  As basic Hoare logic is strongly related to Morgan's
refinement calculus~\cite{Morgan94}, it seems equally reasonable to
ask wether a Morgan-style \emph{differential refinement calculus}
($\dR$) would allow constructing hybrid programs from specifications.

A prima facie answer to these questions seems positive: after all, the
rules of Hoare logic are derivable within dynamic logic and the laws
of Morgan's refinement calculus can be proved using Hoare logic. But
the formalisms envisaged might not be expressive enough for hybrid
program verification or less suitable than $\dL$ in
practice. Conceptually it also seems interesting to ask what it would
take to extend a standard Hoare logic or refinement calculus to hybrid
programs.

Our main contribution consists in showing that $\dH$ and $\dR$ are as
feasible and applicable as $\dL$ for verifying hybrid programs and
that developing these novel methods requires merely adding a
Hoare-style axiom and a refinement rule for evolution commands to the
standard formalisms. 

The conceptual simplicity of $\dH$ and $\dR$ is reflected by that of
the Isabelle verification components for them, which reuses extant
components for (refinement) Kleene algebra with
tests~\cite{Kozen97,ArmstrongGS16,afp:vericomp} $(\mathsf{(r)KAT}$) for the propositional
Hoare logic and refinement calculi---ignoring assignment and evolution
commands---and derives axioms and laws for these two basic commands
within a concrete state transformer semantics for hybrid
programs~\cite{MuniveS19} over a generic hybrid store model based on
lenses~\cite{FosterZW16}, reusing mainly other Isabelle
components~\cite{afp:hybrid,afp:simon?}.  Data-level verification
conditions can be discharged using Isabelle's impressive hierarchy for
analysis and ordinary differential equations~\cite{ImmlerH12a}.  

This simple modular development can be seen as a case study evidencing
the benefits of algebraic reasoning and shallow embeddings with proof
assistants. For our verification components, we mainly needed to
replace a relational semantics of $\KAT$ and $\rKAT$ by a state
transformer semantics formalised in~\cite{afp:hybrid}, and a concrete
store semantics for imperative programs by those for hybrid
programs. Using lenses~\cite{FosterZW16} gives us the flexibility to
switch seamlessly between stores using Isabelle's real vector spaces
or executable Euclidean spaces. Beyond that it remained to prove a few
algebraic laws for reasoning with invariants and to derive the
Hoare-axioms and refinement laws for evolution commands in the
concrete semantics. Ultimately, program verification is then performed
within the concrete semantics, but this remains hidden, as Isabelle
tactics generate data-level verification conditions fully
automatically and we have created semantic illusions of clean progam
syntax in correctness specifications.

Our verification components support the usual workflows of $\dL$: both
in $\dH$ and $\dL$, we can reason explicitly with solutions to
differential equations and implicitly with invariant sets. We have
also formalised a third method in which solutions, that is flows,  are declared ab
initio in correctness specifications and need not be certified. 

We have so far evaluated our verification components on a small set of
program construction and verification examples. Some of them are
discussed in detail in this article to explain the different work
flows supported by our approach. With Isabelle tactics for automated
verification condition generation in place, we noticed little
difference compared to previous verification case studies based on
predicate transformers~\cite{MuniveS19}.  The entire Isabelle
development, including the examples, is available
online\footnote{Jonathan's repo}. Replaying proofs requires installing
Isabelle2019, downloading the Archive of Formal Proofs and our
repository. A postscript proof document in the repository allows
inspecting the Isabelle code without engaging with the proof
assistant. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kleene Algebra with Tests}\label{sec:kat} 

% A \emph{Kleene algebra} is a structure $(K,+,\cdot,0,1,^\ast)$, where
% $(S,+,\cdot,0,1)$ is a semiring with idempotent addition and the
% Kleene star $(-)^\ast:K\to K$ satisfies, for all
% $\alpha,\beta,\gamma\in K$, the axioms
% \begin{align*} 
% 1+\alpha\cdot\alpha^\ast &\le \alpha^\ast, \qquad
%   \gamma+\alpha\cdot
%                                           \beta\le \beta\rightarrow \alpha^\ast \cdot \gamma\le \beta,\\
%   1+\alpha^\ast\cdot\alpha &\le \alpha^\ast, \qquad \gamma+\beta\cdot
%                              \alpha\le \beta\rightarrow \gamma\cdot
%                              \alpha^\ast \le \beta.
% \end{align*}


A \emph{Kleene algebra with tests}~\cite{Kozen97} ($\KAT$) is a
structure $(K,B,+,\cdot,0,1,^\ast,\neg)$ where $(B,+,\cdot,0,1,\neg)$
is a boolean algebra with join $+$, meet $\cdot$, complementation
$\neg$, least element $0$ and greatest element $1$, $B\subseteq K$,
and $(K,+,\cdot,0,1,^\ast)$ is a Kleene algebra---a semiring with
idempotent addition equipped with a star operation that satisfies the
axioms $1+\alpha\cdot\alpha^\ast \le \alpha^\ast$ and
$\gamma+\alpha\cdot \beta\le \beta\rightarrow \alpha^\ast \cdot
\gamma\le \beta$,
as well as their opposities, with multiplication swapped.  The
ordering on $K$ is defined by $x\le y\leftrightarrow x+y=y$, as
idempotent semirings are semilattices. We often write $\alpha\beta$
instead of $\alpha\cdot\beta$, and use $p,q,r,\dots$ for elements of $B$.

Elements of $K$ represent programs; those of $B$ tests, assertions or
propositions.  The operation $\cdot$ models the sequential composition
of programs, $+$ their nondeterministic choice, $(-)^\ast$ their
finite unbounded iteration. Program $0$ aborts and $1$ skips.  Tests
are embedded implicitly into programs. They are meant to hold in some
states of a program and fail in others; $p\alpha$ ($\alpha p$)
restricts the execution of program $\alpha$ in its input (output) to
those states where test $p$ holds. The ordering $\le$ is the opposite
of the refinement ordering on programs (see Section~\ref{sec:refine}).

Binary relations of type $\Pow\, (S\times S)$ form
$\KAT$s~\cite{Kozen97} when $\cdot$ is interpreted as relational
composition, $+$ as relational union, $(-)^\ast$ as
reflexive-transitive closure and the elements of $B$ as
subidentities---relations below the relational unit. This grounds
$\KAT$ within standard relational imperative program semantics. Yet we
prefer the isomorphic representation as \emph{state transformers} of
type $S\to \Pow\, S$.  Composition $\cdot$ is then interpreted as
Kleisli composition
\begin{equation*} 
(f\circ_K g)\, x = \bigcup\{g\, y\mid y \in f\ x \}, 
\end{equation*} 
$0$ as $\lambda x.\ 0$ and $1$ as $\eta_S = \{-\}$.  Stars
$f^{\ast}  = \bigcup_{i\in\mathbb{N}} f^i$ are defined with
  respect to Kleisli composition using $f^{0} = \eta_S$ and
  $f^{n+1} = f \circ_K f^{n}$. The boolean algebra of tests has
  carrier set $B_S=\{f:S\to \Pow\, S \mid f\le \eta_S\}$, where the
  order on functions has been extended pointwise,  and complementation
  is given by
  \begin{equation*} 
    \overline{f}\, x =
  \begin{cases}
    \eta_S\, x, & \text{ if } f\, x = \emptyset,\\
\emptyset, & \text{ otherwise}.
  \end{cases}
\end{equation*}
We freely identify predicates, sets and state 
transformers below $\eta_S$, which are isomorphic:
$P\cong \{s\mid P\, s\}\cong \lambda s.\ \{x\mid x=s \land P\, s\}$.

\begin{proposition}\label{P:kleisli-ka}
$\sta\, S = ((\Pow\, S)^S,B_S,\cup,\circ_K,\lambda x.\
  \emptyset, \eta_S,(-)^{\ast},\overline{(-)})$
  forms a $\KAT$, the \emph{full state transformer $\KAT$} over the
  set $S$.
\end{proposition}
A \emph{state transformer $\KAT$} over $S$ is any subalgebra of
$\sta\, S$. 

We have already formalised $\KAT$ via type classes in
Isabelle~\cite{afp:kat}.  These allow only one type parameter. Hence
we use an alternative approach that expands a Kleene algebra $K$ by an
\emph{antitest} function $n:K\to K$ from which a \emph{test} function
$t:K\to K$ is defined as $t=n^2$. Then
$K_t = \{\alpha \mid t\, \alpha = \alpha\}$ forms a boolean algebra in
which $n$ acts as test complementation. It can be used in place of the
boolean algebra $B$.  A formalisation of the state transformer model
of $\KAT$ is a contribution to this article.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Propositional Hoare Logic and Invariants}\label{sec:hl-invariants}

$\KAT$ provides a simple algebraic semantics for while
programs with
\begin{align*}
  \IF{p}{\alpha}{\beta} = p\cdot \alpha + \bar p \cdot
  \beta\qquad\text{ and }\qquad
\WHILE{p}{\alpha} = (p\cdot \alpha)^\ast \cdot \bar p.
\end{align*}
It captures validity of Hoare triples in
a partial correctness semantics as
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow p\alpha\neg q = 0,
\end{equation*}
or equivalently by $p\alpha\le \alpha q$ or $p\alpha = p\alpha q$. It
also allows deriving the rules of \emph{propositional Hoare
  logic}~\cite{Kozen00}---disregarding assignments---which are useful for
verification condition generation:
\begin{align}
  &\{p\}\, \sskip\, \{p\}, \label{eq:h-skip}\tag{h-skip}\\
  p\le p' \land \{p'\}\, \alpha\, \{q'\} \land q'\le q\ \rightarrow\ &
                                                                       \{p\}\,
                                                                       \alpha\,
                                                                       \{q\},\label{eq:h-cons}\tag{h-cons}\\
  \{p\}\, \alpha\, \{r\} \land \{r\}\, \beta\, \{q\}\ \rightarrow\
  &\{p\}\, \alpha\beta\, \{q\},\label{eq:h-seq}\tag{h-seq}\\
  \{tp\}\, \alpha\, \{q\}\land \{\neg tp\}\, \beta\, \{q\}\
  \rightarrow\ & \{p\}\, \IF{t}{\alpha}{\beta}\, \{q\},\label{eq:h-cond}\tag{h-cond}\\
  \{tp\}\, \alpha\, \{p\}\ \rightarrow\ & \{p\}\, \WHILE{t}{\alpha}\, \{\neg tp\}.\label{eq:h-while}\tag{h-while}
\end{align}
Rules for commands with invariant assertions $\alpha\ \mathbf{inv}\ i$
are derivable, too (operationally,
$\alpha\, \mathbf{inv}\, i = \alpha$).  An \emph{invariant} for
$\alpha\in K$ is an $i\in B$ satisfying $\{i\}\, \alpha\, \{i\}$.
Then, with $\mathbf{loop}\, \alpha$ as syntactic sugar for
$\alpha^\ast$, we obtain
\begin{align}
  p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\
  &\{p\}\, \alpha\, \{q\},\label{eq:h-inv}\tag{h-inv}\\
  p \le i \wedge \{it\}\, \alpha\, \{i\} \wedge \neg t i\le q\
  \rightarrow \ & \{p\}\, \WHILEI{t}{i}{\alpha}\,  \{q\},\label{eq:h-while-inv}\tag{h-while-inv}\\
   p\le i \land \{i\}\, \alpha\, \{i\}\land i\le q\ \rightarrow\ &
                                                                   \{p\}\, \mathbf{loop}\, \alpha\,
    \mathbf{inv}\, i\, \{q\}. \label{eq:h-loop-inv}\tag{h-loop-inv}
\end{align}
We use (\ref{eq:h-inv}) to reason about invariants for continuous
evolutions of hybrid systems in Section~\ref{sec:hoare-inv},
\ref{sec:refine} and \ref{sec:from-flows}. Rule (\ref{eq:h-while-inv})
is standard for reasoning with invariants for while loops;
(\ref{eq:h-loop-inv}) is specific to loops of hybrid programs (see
Section~\ref{sec:sta-hybrid}).

The rules for propositional Hoare logic in Isabelle have been derived
for $\KAT$ in~\cite{afp:kat,afp:vericomp}. Generic Isabelle
infrastructure for reasoning with invariants has been developed
especially for this article.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{State Transformer Semantics of Hybrid
  Programs}\label{sec:sta-hybrid}

\gin{Simon: add some paras on lenses.}

Hybrid programs of differential dynamic logic ($\dL$)~\cite{Platzer18}
are defined by the syntax
\begin{equation*}
\mathcal{C}\ ::= \ x:=e \mid x' = f \, \&\, G \mid ?P\mid \mathcal{C};\mathcal{C}\mid \mathcal{C}+\mathcal{C}\mid \mathcal{C}^*
\end{equation*}
that adds \emph{evolution commands} $x' = f \, \&\, G$ to the language
of $\KAT$---function $?(-)$ embeds tests explicitly into programs.
Evolution commands introduce a time independent vector field $f$ for
an autonomous system of ordinary differential equations
(ODEs)~\cite{Teschl12} together with a guard $G$, a predicate
modelling boundary conditions or similar restrictions on temporal
evolutions. % Guards are also known as \emph{evolution domain
  % restrictions}~\cite{DoyenFPP18}.

Formally, vector fields are functions of type $S\to S$ on some open set
$S\subseteq \reals^n$ and $n\in\mathbb{N}$---the state space of
the hybrid program. We assume that program variables range from $0$ to
$n-1$, or pick them from any set $V$ isomorphic to the finite ordinal
$n$. Program states in $S$ can thus be identified with hybrid program
stores modelled as functions from variables in $V$ to values in
$\reals$, as usual.

Geometrically, vector field $f$ assigns a vector to any point of the
state space
$S$. A solution to the \emph{initial value problem} (IVP) for the pair
$(f,s)$ and initial value $(0,s)\in T\times S$, where $T$ is an open
interval in $\reals$ containing $0$, is then a function $X:T\to S$
that satisfies $X'\, t = f\, (X\, t)$---an autonomous system of ODEs
in vector form---and $X\, 0 = s$. Solution
$X$ is thus a curve in $S$ through $s$, parametrised in $T$ and
tangential to $f$ at any point in $S$; it is called \emph{trajectory}
or \emph{integral curve} of $f$ at $s$ whenever it is uniquely
defined ~\cite{Teschl12}.

For IVP $(f,s)$ with continuous vector field $f:S\to S$ and initial
state $s\in S$ we define the set of solutions on
$T$ as
\begin{equation*}
\Sols f\, T\, s = \{X \mid \forall t\in T.\  X'\, t = f\, (X\, t)\land X\, 0 = s\}.
\end{equation*}
Each solution $X$ is then continuously differentiable and thus
$f\circ X$ integrable in $T$.  For $X\in \Sols\, f\, T\, s$ and
$G:S\to\bools$, we further define the $G$-\emph{guarded orbit} of $X$
along $T$ in $s$~\cite{MuniveS19} with the help of the state transformer
$\gamma^X_G:S\to \Pow\, S$ as 
\begin{equation*}
\gamma^X_{G}\, s= \{X\, t\mid t\in T\land \forall \tau\in
{\downarrow}t.\ G\, (X\, \tau)\},
\end{equation*}
where ${\downarrow}t = \{t'\in T\mid t'\le t\}$, and the
$G$-\emph{guarded orbital} of $f$ along $T$ in $s$~\cite{MuniveS19}
via the state transformer $\gamma^f_G:S\to \Pow\, S$ as
\begin{equation*}
  \gamma^f_G\ s = \bigcup\{\gamma^X_G\, s\mid X\in \Sols\, f\, T\, s\}.
\end{equation*}
In applications, ${\downarrow}t$ is usually an interval
$[0,t]\subseteq T$.  Expanding definitions,
\begin{equation*}
\gamma^f_G\, s = \{X\, t \mid X\in \Sols\, f\, T\, s \land t\in T
\land \forall \tau\in{\downarrow}t.\ G\, (X\, \tau)\}.
\end{equation*}
If $\top$ denotes the predicate that holds of all states in $S$ (or
the set $S$ itself), we write $\gamma^f$ instead of
$\gamma^f_\top$. We define the semantics of the evolution command
$x'= f\, \&\, G$~\cite{MuniveS19} for any continuous $f:S\to S$ and
$G:S\to \bools$ as
\begin{equation}
{(x'= f\, \&\, G)} = \gamma^f_G.\label{eq:st-evl}\tag{st-evl}
\end{equation}

Defining the state transformer semantics of assignments is
standard~\cite{MuniveS19}. First we define a state update
function $f_a:V\to (S \to E) \to S\to S$ as
\begin{equation*}
f_a\, x\, e\, s = s[x\mapsto e\, s],
\end{equation*}
where $f[a\mapsto b]$ updates $f:A\to B$ by associating $a\in A$ with
$b$ and every $y\neq a$ with $f\, y$.  The ``expression''
${e:S\to \reals}$ is thus evaluated in state $s$ to $e\, s$.  Then we
lift $f_a\, x\, e:S\to S$ to state transformer
$x:= e:S \to \Pow\, S$ using $\eta_S$:
\begin{equation}
  (x:= e) = \lambda s.\ \{f_a\, x\, e\, s\}.\label{eq:st-assgn}\tag{st-assgn}
\end{equation}

The development in this section has already been formalised with
Isabelle~\cite{afp:hybrid}, both for a state transformer and a
relational semantics. An instance of the latter for particular vector
fields with unique solutions forms the standard semantics of
$\dL$. Due to the connection to orbits or orbitals, the state
transformer semantics is arguably conceptually simpler and more
elegant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Flow-Based Hoare Logic for Hybrid
  Programs}\label{sec:hoare-flow}

The assignment axiom of Hoare logic need not be explained. Our
semantics yields a variant with update functions instead
of substitutions:
\begin{equation}
\{\lambda s.\ P\, s[x\mapsto e\, s]\}\,  x:=e\, \{P\}. \label{eq:h-assgn}\tag{h-assgn}
\end{equation}
Hence all we need to add to Hoare logic is a rule for evolution
commands.  We restrict our attention to Lipschitz-continuous vector
fields for which unique solutions to IVPs are guaranteed by
Picard-Lindel\"of's theorem~\cite{Teschl12}.  These are \emph{(local)\
  flows} $\flow:T\to S\to S$ and $X=\flow_s=\lambda t.\ \flow\, t\, s$
is the trajectory at $s$. Guarded orbitals $\gamma^f_G$ then
specialise to \emph{guarded orbits}
\begin{equation*}
  \gamma^f_{G,U} = \{\flow_s\, t\mid t\in U\land \forall\tau \in
  {\downarrow}t.\ G\, (\flow_s\, t)\},
\end{equation*}
where $U\subseteq T$ is a time domain of interest, typically an
interval $[0,t]$ for some $t\in T$~\cite{MuniveS19}.  Accordingly,
(\ref{eq:st-evl}) becomes
\begin{equation}
  (x' = f\, \&\, G)= \gamma^f_{G,U}.\label{eq:st-evl-flow}\tag{st-evl-flow}
\end{equation}
The following Hoare-style rule for evolution commands is then
derivable.
\begin{lemma}\label{P:h-evl-lemma}
\gin{add the right conditions}
\begin{equation}
\{\lambda s\in S.\forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)) \rightarrow P\,
(\flow_s\, t)\}\, x' = f\, \&\, G\, \{P\}. \label{eq:h-evl}\tag{h-evl}
\end{equation}
\end{lemma}

This finishes the derivation of rules for an algebraic Hoare logic for
hybrid programs---to our knowledge, the first Hoare logic of this
kind. As usual, there is one rule per programming construct, so that
their recursive application generates proof obligations that are
entirely about data-level relationships---the discrete and continuous
evolution of hybrid program stores.

The rule~(\ref{eq:h-evl}) supports the following procedure
for reasoning with an evolution command $x' = f\, \&\, G$ and set $U$
in this calculus:
\begin{enumerate}
\item Check that vector field $f$ satisfies the conditions for
  Picard-Lindel\"of's theorem ($f$ is Lipschitz continuous and
  $S\subseteq\reals^n$ is open).
\item Supply a (local) flow $\flow$ for $f$ with open interval of
  existence $T$ around $0$.
\item Check that $\flow_s$ solves the IVP $(f,s)$ for each $s\in S$;
  that is, $\flow_s'\, t = f\, (\flow_s\, t)$, $\flow_s\, 0 = s$, and
  $U\subseteq T$.
\item If successful, apply rule~(\ref{eq:h-evl}).
\end{enumerate}

\gin{add example: thermostat (done)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Invariant-Based Hoare Logic for Hybrid Programs}\label{sec:hoare-inv}

Alternatively, our Hoare logic supports reasoning with invariants for
evolution commands instead of supplying flows to~(\ref{eq:h-evl}).
The approach has been developed in~\cite{MuniveS19}. Our invariants
generalise the \emph{differential invariants} of
$\dL$~\cite{Platzer18} and the \emph{invariant sets} of dynamical
systems and (semi)group theory~\cite{Teschl12} .

A predicate $I:S\to\bools$ is an \emph{invariant} of the continuous
vector field $f:S\to S$ and guard $G:S\to\bools$ \emph{along}
$T\subseteq \reals$ if
\begin{equation*}
\bigcup \Pow\, \gamma^f_G\, I\subseteq  I.
\end{equation*}
The operation $\bigcup\circ\Pow$ is the Kleisli extension $(-)^\dagger$
in the powerset monad. Hence we could simply write
$(\gamma^f_gG)^\dagger\, I \subseteq I$. The definition of invariance
unfolds to
\begin{equation*}
  \forall s.\ I\, s \to (\forall X\in\Sols f\, T\, s.\forall t\in T.\ (\forall \tau\in {\downarrow}t.\ G\, (X\, \tau)) \to I\, (X\, t)).
\end{equation*}
For $G=\top$ we call $I$ an \emph{invariant} of $f$ along $T$.
Intuitively, invariants can be seen as sets of orbits.

Invariants for evolution commands are coherent with those in Section~\ref{sec:hl-invariants}.
\begin{proposition}\label{P:inv-prop}
  Let $f:S\to S$ be continuous, $G:S\to\bools$ and
  $T\subseteq \reals$. Then $I$ is an invariant for $f$ and $G$ \emph{along} $T$ if and only if
$ \{I\}\, x' = f\, \&\, G\, \{I\}$.
\end{proposition}
Hence we can use an instance of (\ref{eq:h-inv}) for verification condition generation:
\begin{align}
  P\le I \land \{I\}\, x' = f\, \&\, G\, \{I\}\land (I\cdot G)\le Q\ \rightarrow\
  &\{P\}\, x' = f\, \&\, G\, \{Q\}.\label{eq:h-invg}\tag{h-invg}
\end{align}
It remains to check invariance in the antecedent of this rule. The
following lemma leads to a procedure.

\begin{lemma}\label{P:invrules}
  Let $f:S\to S$ be a continuous vector field, $\mu,\nu:S\to\reals$
  differentiable and $T\subseteq \reals$. 
\begin{enumerate}
\item If $(\mu\circ X)' =(\nu\circ X)'$ for all
  $X\in \Sols f\, T\, s$, then $\{\mu=\nu\}\, x' = f\, \&\, G\, \{\mu=\nu\}$, 
\item if $(\mu\circ X)'\, t\leq(\nu\circ X)'\, t$ when $t> 0$, and $(\mu\circ X)'\, t\geq(\nu\circ X)'\, t$ when $t< 0$, for all $X\in \Sols f\, T\, s$,
  then $\{\mu <\nu\}\, x' = f\, \&\, G\, \{\mu <\nu\}$
\item $\mu\neq \nu$ if and only if $\mu < \nu$ or $\nu < \mu$,
\item $\mu \not\le \nu$ if and only if $\nu < \mu$,
\jin{get Hoare triple version in Isabelle}
\item if $\{I_i\}\, x' = f\, \&\, G\, \{I_i\}$for $i\in\{1,2\}$, then $\{I_1\land I_2\}\, x' = f\, \&\, G\, \{I_1\land I_2\}$ and $\{I_1\lor I_2\}\, x' = f\, \&\, G\, \{I_1\lor I_2\}$.
%\item if $I_1$ and $I_2$ are differential invariants for $f$ along $T$, then so are $\lambda s.\ I_1\, s \land I_2\, s$ and $\lambda s.\ I_1\, s \lor I_2\, s$.
\end{enumerate}
\end{lemma}

Condition $(1)$ follows from the well known fact that two continuously
differentiable functions are equal if they intersect at some point and their
derivatives are equal. Therefore, rule (\ref{eq:h-invg}),
Proposition~\ref{P:inv-prop} and Lemma~\ref{P:invrules} yield the following
procedure for verifying a triple $\{P\}\, x' = f\, \&\, G\, \{Q\}$
using an invariant.
\begin{enumerate}
\item Check whether a candidate predicate $I$ is an invariant for $f$
  along $T$:
	\begin{enumerate}
	\item transform $I$ into negation normal form;
	\item if $I$ is complex, reduce it with Lemma~\ref{P:invrules} (3), (4) and (5);
	\item if $I$ is atomic, apply Lemma~\ref{P:invrules} (1) and (2);
	\end{enumerate}
(if successful,  $\{I\}\, x' = f\, \&\, G\, \{I\}$ holds by Proposition~\ref{P:inv-prop}),
\item if successful, prove $P\le I$ and $(I\cdot G)\le Q$ to apply rule (\ref{eq:h-invg}).
\end{enumerate}

\gin{add example: water tank (done)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Refinement Calculi for Hybrid Programs}\label{sec:refine}

A \emph{refinement Kleene algebra with tests}
($\rKAT$)~\cite{ArmstrongGS16}  is a $\KAT$
$(K,B)$ expanded by an operation $[-,-]:B\times B\to K$ that
satisfies, for all $\alpha \in K$ and $p,q\in B$, 
\begin{equation*}
  \{p\}\, \alpha\, \{q\} \leftrightarrow \alpha\le [p,q].
\end{equation*}
The element $[p,q]$ of $K$ corresponds to Morgan's \emph{specification
  statement}~\cite{Morgan94}. It satisfies
\begin{equation*}
  \{p\}\, [p,q]\, \{q\}\qquad \text{ and }\qquad \{p\}\, \alpha\, \{q\} \rightarrow \alpha\le [p,q],
\end{equation*}
which makes $[p,q]$ the greatest element of $K$ that satisfies the Hoare
triple with precondition $p$ and postcondition $q$.  Indeed, in
$\sta\, S$ and for $S\subseteq \reals^n$,
\begin{equation*}
  [P,Q] = \bigcup \left\{f:S\to \Pow\, S \mid \{P\}\, f\, \{Q\}\right\}.
\end{equation*}

Variants of Morgan's laws~\cite{Morgan94} of a \emph{propositional
  refinement calculus}---once more ignoring assignments---are then derivable in
$\rKAT$~\cite{ArmstrongGS16}.
\begin{align}
  1 &\le [p,p],\label{eq:r-skip}\tag{r-skip}\\
[p',q'] &\le [p,q],\qquad \text{ if } p\le p'\text{ and } q'\le q,\label{eq:r-cons}\tag{r-cons}\\
\alpha & \le [0,1],\\
[1,0] &\le \alpha,\\
[p,r]\cdot [r,q] &\le [p,q],\label{eq:r-seq}\tag{r-seq}\\
\IF{t}{[tp,q]}{[\neg tp,q]} &\le [p,q],\label{eq:r-cond}\tag{r-cond}\\
 \WHILE{t}{[tp,p]} &\le [p,\neg tp]. \label{eq:r-while}\tag{r-while}
\end{align}
For invariants and loops, we obtain the additional refinement laws
\begin{align}
  [i,i] &\le [p,q],\qquad \text{ if } p\le i \le q,\label{eq:r-inv}\tag{r-inv}\\
\mathbf{loop} [i,i] &\le [i,i]. \label{eq:r-loop}\tag{r-loop}
\end{align}

In $\sta\, S$, moreover, the following assignments laws are
derivable~\cite{ArmstrongGS16}.
\begin{align}
 (x := e)  &\le  [\lambda s.\ P\, s[x\mapsto e\, s],P],\label{eq:r-assgn}\tag{r-assgn}\\
(x:= e) \cdot [\lambda s.\ P\, s[x\mapsto e\, s],P] &\le [P,P],\label{eq:r-assgn}\tag{r-assgnl}\\
[P,\lambda s.\ P\, s[x\mapsto e\, s]]\cdot (x:=e) &\le [P,P]. \label{eq:r-assgn}\tag{r-assgnf}
\end{align}
The second and third law are known as \emph{leading} and \emph{following}
law. They introduce an assignment before and after a block of code. 

Finally, we obtain the following refinement laws for evolution
commands.
\begin{lemma}\label{P:r-evl-lemma}
\gin{add conditions}
\begin{equation}
x' = f\, \&\, G \le [\lambda s.\forall t\in U.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to P\, (\flow_s\, t),P]. \label{eq:r-evl}\tag{r-evl}
\end{equation}
\end{lemma}

\gin{we also need to derive leading/following laws
  for evolution statements.}

These laws suffice for constructing hybrid programs from initial
specification statements by step-wise refinement incrementally and
compositionally. To our knowledge this is the first refinement
calculus for hybrid programs of this kind.  A more powerful variant
based on predicate transformers \`a la Back and von
Wright~\cite{BackW98} has been developed in~\cite{MuniveS19}, but
applications remain to be explored.  A previous approach to refinement
for hybrid programs in $\dL$~\cite{LoosP16} seems quite different to
the two standard calculi mentioned and much more intricate than the
approach presented.

\gin{do two examples; one for flows (thermostat, stepwise, done), one for
  invariants (water tank, in one go,  with ex euclidean space, tbd).}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Starting from Flows}\label{sec:from-flows}

Finally, we present an approach that starts directly from
flows $\flow:T\to S\to S$ instead of vector fields.  This avoids
checking the conditions of the Picard-Lindel\"of theorem and
simplifies verification proofs considerably.  Instead of $x'=f\, \&\,
G$, we now use the basic evolution command $\mathbf{evol}\, \flow\, G$
in hybrid programs and define
\begin{equation*}
  (\mathbf{evol}\, \flow\, G) = \lambda s.\ \gamma^{\flow_s}_G\, s
\end{equation*}
with respect to the guarded orbit of $\flow_s$ along $T$ in $s$. It
then remains to derive a Hoare-style axiom and a refinement law
for such evolution commands. This is straightforward.
\begin{lemma}\label{P:hr-evlfl}
\gin{add conditions}
\begin{gather}
\{\lambda s\in S.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau)) \rightarrow P\,
(\flow_s\, t)\}\, \mathbf{evol}\, \flow\, G\, \{P\}. \label{eq:h-evlfl}\tag{h-evlfl}\\
\mathbf{evol}\, \flow\, G \le [\lambda s.\forall t\in T.\ (\forall
\tau\in {\downarrow}t.\ G\, (\flow_s\, \tau))\to P\, (\flow_s\, t),P]. \label{eq:r-evlfl}\tag{r-evlfl}
\end{gather}
\end{lemma}

\gin{do following and leading assignments laws and bouncing ball
  examples for verification (done) and refinement (step wise, with ex euclidean
  space, tbd).}

\begin{example}[Bouncing ball via Hoare logic]\label{ex:ball-hoare}
  Suppose a ball of mass $m$ falls down from height $h\geq 0$, with
  $x$ denoting its position, $v$ its velocity and $g$ its
  acceleration. Its kinematics is modelled by the vector field
  $f:\reals^V\to\reals^V$ with
 \begin{equation*}
    f\,
    \begin{pmatrix}
      s_x\\
      s_v
    \end{pmatrix}
=
\begin{pmatrix}
  s_v\\
-g
\end{pmatrix},
\end{equation*}
where we abbreviate
$s_x = s\, x$ and $s_v = s\, v$.  It bounces back
from the ground in an elastic collision, which is modelled using a
discrete control that checks whether $s_x=0$ and then flips the
velocity.  Guard $G=(\lambda s.\ s_x\geq 0)$ excludes any motion
below the ground. This is modelled by the hybrid
program~\cite{Platzer18}
\begin{align*}
	\mathsf{Cntrl} &= \IF {(\lambda\, s.\ s_x=0)} {v:=(\lambda\, s.\ - s_v)} \mathit{skip},\\
	\mathsf{Ball} &= ({x'=f\, \&\, G}\,  {;}\, \mathsf{Cntrl})^\ast.
\end{align*}
Its correctness specification is
\begin{equation*}
\{P\}\, \mathsf{Ball}\, \{Q\}
\end{equation*}
for $P= (\lambda s.\ s_x = h\land s_v = 0)$ and $Q  = (\lambda s.\
0\leq s_x\leq h)$; its loop invariant
\begin{equation*}
      I = \left(\lambda s.\ 0\le s_x \land \frac{1}{2}s_v^2= g(h - s_x)\right).
\end{equation*}
\gin{put isabelle stuff here.}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}\label{sec:conclusion}

This article on Hoare logics and refinement calculi for hybrid
programs in the style of $\dL$ is a companion to another article that
introduces a more complex and powerful predicate transformer based
framework for reasoning about hybrid systems, formalised with
Isabelle/HOL~\cite{MuniveS19}. The verification components contribute
the following to this framework:
\begin{itemize}
\item the first standalone Hoare logic for hybrid programs, 
\item the first Morgan-style refinement calculus for such programs,
\item more generic state spaces modelled by lenses,
\item improved Isabelle syntax for correctness specifications
  and hybrid programs,
\item increased proof automation via Isabelle tactics. 
\end{itemize}
As previously~\cite{MuniveS19}, our frameworks supports evolution
statements based on Lipschitz-continuous vector fields, where flows
need to be supplied externally and can then be certified internally,
evolution statements based on continuous vector fields, for which
reasoning with invariant sets is supported, and evolution states based
directly on flows, which circumvents their certification. 

Compared to the standard $\dL$ toolchain, the methods presented are
conceptually simple. They emphasise the natural mathematical style of
reasoning about dynamical systems, with little formal overhead
relative to standard Hoare logics and refinement calculi, instead of
using an intricate idiosyncratic proof system. In post hoc
verification, in particular, the only purpose of the inference system
is to be invisible in verification condition generation. The modular
approach based on algebras and a shallow embedding has made it also
very simple to build these verification components and has allowed
high reuse of extant Isabelle code. This makes our framework not only
open to use any proof method and mathematical data supported by
Isabelle's higher-order logic, type system and libraries, it should
also allow developers to add new methods, for instance based on
discrete dynamical systems, hybrid automata or duration
calculi~\cite{***} with relative ease. It should be equally simple to
develop $\dH$ and $\dR$ without using $\KAT$ and $\rKAT$, for instance
in other Hoare logics supported by Isabelle, simply by plugging in our
hybrid store model.

The naturality and importance of using Hoare logic and refinement
calculi for hybrid systems verification is further underpinned by the
fact that these ideas are not new: a hybrid Hoare logic has been
proposed by Liu et al.~\cite{LiuLQZZZZ10} for a duration calculus
based on hybrid CSP and successfully used in subsequent work. It is
therefore syntactically and semantically very different from $\dH$. A
differential refinement logic has been developed in Loos' PhD thesis
and published in~\cite{LoosP16}.  It provides essentially a complex
proof system with a large number of inference rules for reasoning
about inequalities between Kleene algebra expressions that can be seen
as refinements between hybrid programs. The approach is very different
from the algebraic refinement calculi developed by Back and von
Wright~\cite{BackW98}, Morgan~\cite{Morgan94}, and hence very
different from the predicate transformer based approach
in~\cite{MuniveS19} and in particular that based on specification
statements used in $\dR$.  The relative advantages and disadvantages
of the three approaches remain to be explored.

The difference in complexity and expressivity between Hoare logic and
predicate transformer calculi, which is one of the motivations of this
work, can be nicely explained in the algebraic setting. The equational
theory of $\KAT$ is PSPACE complete, that of modal Kleene
algebra, which yields predicate transformers, is in
EXPTIME~\cite{MollerS06}.  Propositional Hoare logic can be
represented within the equational theories.  Moreover, the weakest
liberal precondition operator---a standard predicate transformer---can
be expressed in modal Kleene algebra, but not in
$\KAT$~\cite{Struth18}. 

Finally, while $\KAT$ and $\rKAT$ seem convenient starting points for
building program construction and verification components for hybrid
programs, the simple more general setting of Hoare semigroups~\cite{Struth18}
would support developing hybrid Hoare
logics for total program correctness---where bouncing balls might
bounce forever---or even for multirelational
semantics~\cite{FurusawaS16,FurusawaS15} needed for Isabelle
components for differential game logic~\cite{Platzer15}. This,
however, is left for future work.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\bibliographystyle{abbrv}
\bibliography{hybrid-kat.bib}

\end{document}